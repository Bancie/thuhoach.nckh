\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{vietnam}\usepackage{amsmath, amsthm, amssymb,latexsym,amscd,amsfonts,enumerate}
\usepackage[top=3.5cm, bottom=3.0cm, left=3cm, right=3.0cm]{geometry} 
\usepackage{color, fancyhdr, graphicx, wrapfig}
\usepackage[unicode]{hyperref}
\usepackage[vietnamese]{babel}
\usepackage{titling}
\usepackage{amsmath, amsthm, amssymb,latexsym,amscd,amsfonts,enumerate}
\usepackage{subfigure}
\usepackage{secdot}
\usepackage{graphicx}
\usepackage{tree-dvips}
\usepackage{qtree}
\usepackage{booktabs}
\usepackage{pgfgantt}
\usepackage{tabularx}
\usepackage{ltablex}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx} 
\usepackage{titling}
\usepackage{secdot}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{forest}
\usepackage{tikz-qtree}
\usepackage{array}
\usetikzlibrary{calc}
\usepackage{longtable}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{exscale,relsize,makeidx}
\usepackage{color, fancyhdr, graphicx, wrapfig}
\graphicspath{ {figures/} }

\renewcommand{\listfigurename}{List of plots}
\renewcommand{\listtablename}{List of Tables}
\usepackage{amsmath}
\usepackage{textpos}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{caption}
\usetikzlibrary{shapes.geometric, arrows}
\usetikzlibrary{datavisualization} 
\pgfplotsset{compat=1.18, width = 7cm}
\usetikzlibrary{patterns}
\usepackage{enumitem}
\usepackage{array}
\usepackage[tikz]{ocgx2}
\usepackage{xcolor}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{tikz}
\usepackage{subcaption}
\usepackage{changepage}
\usepackage{float}
\usepackage{pgfplotstable}
\usepackage{pgfplots}
\usepackage{blindtext}
\usepackage{titlesec}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{nccmath}
\usetikzlibrary{calc}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{exscale,relsize,makeidx}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}
\newtheorem{dn}{Định nghĩa}
\newtheorem{tc}{Tính chất}
\newtheorem{dl}{Định lý}
\newtheorem{md}{Mệnh đề}
\newtheorem{bd}{Bổ đề}
\newtheorem{hq}{Hệ quả}
\newtheorem{nx}{Nhận xét}
\newtheorem{vd}{Ví dụ}
\newtheorem{cm}{Chứng minh}
\newtheorem{cy}{Chú ý}
\newtheorem{ttoan}{Thuật toán}
\pagenumbering{roman}\pagestyle{plain}
\renewcommand{\headrulewidth}{1,2pt} 			
\renewcommand{\footrulewidth}{1,2pt}
\newcommand{\dstc}[2]
{
	\newdimen\stringwidth\setbox0=\hbox{#1}
	\stringwidth=\wd0
	\hspace*{-\parindent}\hspace*{.5\textwidth}\hspace*{-.5\wd0}#1\hfill #2\bigskip
}  
\usepackage{scrextend}
\fancyhf{}
\lhead{}
\chead{\thepage}
\rhead{}
\cfoot{}
\rfoot{}
\lfoot{}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{1pt}
\begin{document} 
    \begin{titlepage}
	\centering
    \phantom{}\par
	\vspace{3cm}
	{\LARGE\textbf{SINGLE MACHINE SCHEDULING}\par}
	\vspace{1cm}
	\rule{5cm}{0.5pt}\par
	\vspace{1cm}
		{\LARGE\textbf{BÀI TOÁN LẬP LỊCH CHO MÁY ĐƠN}\par}
	\vspace{1cm}
	\Large\textbf{Nguyễn Chí Bằng}\par		
	\vspace{1cm}
    \today
    \end{titlepage}

	\addcontentsline{toc}{chapter}{Mục lục}
	\tableofcontents

	\chapter*{Danh mục ký hiệu và ý nghĩa}
	\thispagestyle{fancy}
	\addcontentsline{toc}{chapter}{Danh mục các kí hiệu}
	\begin{tabularx}{\linewidth}{ c  X }
		$\alpha | \beta | \gamma$ & Ký hiệu dùng để nhận dạng loại bài toán. Trong đó, trường $\alpha$ chỉ số lượng máy cần lập lịch, trường hợp cho máy đơn ta ký hiệu $\alpha = 1$, tức $1| \beta | \gamma$. Trường $\beta$ chỉ đặc tính hay kiểu ràng buộc của bài toán. Trường $\gamma$ chỉ hàm mục tiêu cần tối ưu. \\
		\\
		$J_{ij}$ & Công việc (job) thứ $j$ được xử lý trên máy thứ $i$, trong trường hợp đơn máy thì $i=1$, kể từ đây ta chỉ ký hiệu $J_j$. \\
		\\
		$p_j$ & Khoảng thời gian xử lý (processing time) của công việc thứ $j$ hay quá trình của công việc thứ $j$, tức từ thời điểm bắt đầu xử lý công việc đến thời điểm hoàn thành công việc. \\
		\\
		$d_j$ & Thời điểm đáo hạn (due date) của công việc thứ $j$. \\
		\\
		$C_j$ & Thời điểm hoàn thành (completion time) của công việc thứ $j$. \\
		\\
		$C_{\max}$ & Thời gian hoàn thành tối đa (makespan) của toàn bộ công việc, được tính bằng công thức $C_{\max} = \underset{1 \leq j \leq n}{\max} C_j$. \\
		\\
		$S_j$ & Thời điểm bắt đầu (starting time) của công việc thứ $j$, được định nghĩa bằng công thức $S_j = \max (C_{j-1}, r_j)$. \\
		\\
		$r_j$ & Thời điểm sẵn sàng (release time) của công việc thứ $j$. Nếu $r_j \neq 0$ thì công việc thứ $j$ sẽ không được phép bắt đầu trước thời điểm sẵn sàng $r_j$ ($S_j \geq r_j$), ngược lại, nếu $r_j = 0$ thì công việc thứ $j$ sẽ được phép bất đầu tại bất kỳ thời điểm nào. \\
		\\
		$W_j$ & Thời gian chờ (waiting time) của công việc thứ $j$, tức khoảng thời gian kể từ thời điểm công việc đã sẵn sàng cho đến thời điểm bắt đầu công việc, được định nghĩa bằng công thức $W_j = S_j - r_j = C_j - p_j - r_j$. \\
		\\
		$F_j$ & Chu trình (flow time) của công việt thứ $j$, tức khoảng thời gian kể từ thời điểm công việc đã sẵn sàng cho đến khi hoàn thành, được định nghĩa bằng công thức $F_j = C_j - r_j = W_j + p_j$. \\
		\\
		$w_j$ & Trọng số (weight) của công việc thứ $j$, tức mức độ ưu tiên để được xử lý của công việc thứ $j$. \\
		\\
		$L_j$ & Độ đáo hạn (lateness) của công việc thứ $j$, được định nghĩa là độ dài từ $d_j$ đến $C_j$, xác định bằng công thức $L_j=C_j-d_j$. Từ đây có thể thấy, nếu $L_j < 0$ thì công việc đã hoàn thành sớm hơn thời điểm đáo hạn, nếu $L_j > 0$ thì công việc đã hoàn thành muộn hơn thời điểm đáo hạn. \\
		\\
		$T_j$ & Độ trễ (tardiness) của công việc thứ $j$, là thang đo độ trễ của công việc thứ $j$ được định nghĩa thông qua $L_j$. Nếu $L_j \leq 0$ thì $T_j=0$, ngược lại nếu $L_j > 0$ thì $T_j = L_j$, hay $T_j=\max (L_j,0)$. \\
		% Sự khác biệt giữa $T_j$ và $L_j$ đó là $T_j$ chỉ tập trung vào độ trễ, trong khi đó $L_j$ tập trung vào m  \\
		\\
		$E_j$ & Độ sớm (earliness) của công việc thứ $j$, là thang đo độ sớm của công việc thứ $j$ được định nghĩa thông qua $L_j$. Nếu $L_j \geq 0$ thì $E_j=0$, ngược lại nếu $L_j < 0$ thì $E_j = L_j$, hay $E_j=\max (|L_j|,0)$. \\
		\\
		$prec$ & Bài toán tồn tại ràng buộc có thứ tự (precedence constraint). Nếu $prec$ xuất hiện trong trường $\beta$ của bài toán thì bài toán tồn tại những công việc đòi hỏi phải hoàn thành trước khi công việc khác được bắt đầu, hay còn gọi là công việc tiền nhiệm (predecessor) và công việc kế nhiệm (successor). Nếu trường hợp bài toán có mỗi công việc tồn tại tối đa một tiền nhiệm và một kế nhiệm, bài toán có ràng buộc dạng dây chuyền (chains). Trường hợp có tối đa một kế nhiệm, bài toán có ràng buộc dạng in-tree. Trường hợp có tối đa một tiền nhiệm, bài toán có ràng buộc dạng out-tree. Ngược lại, nếu $prec$ không xuất hiện trong trường $\beta$ của bài toán, bài toàn được phép có các thứ tự công việc được sắp tự do. \\
		\\
		$prmp$ & Bài toán tồn tại tính ưu tiên ngắt (preemption), thường được sử dụng khi có sự xuất hiện của $r_j \neq 0$. Nếu $prmp$ xuất hiện trong trường $\beta$ của bài toán thì công việc được phép ngắt quãng tại bất kỳ thời điểm nào để ưu tiên cho công việc khác nhằm mục đích tối ưu hàm mục tiêu của bài toán. Ngược lại, nếu $prmp$ không xuất hiện trong trường $\beta$ của bài toán, công việc sẽ không được phép ngắt quãng. \\
	\end{tabularx}
\newpage
\pagenumbering{arabic} 

\chapter{Giới thiệu bài toán lập lịch cho máy đơn và thuật toán xử lý}
\section{Khái quát về bài toán lập lịch}
Vấn đề lập lịch hay còn gọi là quản lý thời gian và tối ưu hoá quy trình là một lĩnh vực quan trọng trong \textit{Vận trù học (Operation research)} giúp ra quyết định phân bổ thời gian hợp lý và được sử dụng thường xuyên trong nhiều ngành công nghiệp sản xuất, dịch vụ, khoa học máy tính và trí tuệ nhân tạo. Động cơ của lĩnh vực lập lịch liên quan đến việc phân bổ tài nguyên cho các nhiệm vụ trong các khoảng thời gian nhất định nhằm tối ưu hóa một hàm mục tiêu cụ thể.

Mục tiêu của lập lịch rất đa dạng, tuỳ theo nhu cầu của nhà lập lịch, mục tiêu có thể là giảm thiểu thời gian hoàn thành của công việc cuối cùng hoặc giảm thiểu số lượng công việc bị trễ so với thời điểm đáo hạn tương ứng của chúng, cả hai là thuật toán cốt lõi sẽ được tập trung trong mục 1.2.

Tuỳ thuộc theo dạng bài toán yêu cầu mà ta sẽ có phương pháp tiếp cận và xử lý khác nhau. Ở đây ta chỉ tập trung xử lý cái bài toán cho máy đơn ($\alpha = 1$), các dạng bài toán được chia theo bảng bên dưới
\begin{figure}[h!]
	\centering
	\begin{tabular}{| c || c| c c c c |} 
	\hline
	&&& $\gamma$ && \\
	\hline\hline
	&& $C_{\max}$ & $L_{\max}$ & $T_{\max}$ & $\sum w_j C_j$ \\
	\hline
	& $\varnothing$ & $1\|C_{\max}$ & $1\|L_{\max}$ & $1\|T_{\max}$ & $1\|\sum w_j C_j$ \\
	$\beta$ & $prec$ & \phantom{} & $\phantom{}$&$\phantom{}$ & $1|prec|\sum w_j C_j$ \\
	& $r_j$ & $1|r_j|C_{\max}$ &$1|r_j|L_{\max}$ &$\phantom{}$ &$\phantom{}$ \\
	& $r_j, prmp$ & \phantom{} &$1|r_j, prmp|L_{\max}$&$\phantom{}$&$\phantom{}$ \\
	\hline
	\end{tabular}
	\caption{Bảng liệt kê các dạng bài toán.}
\end{figure}

 Ở phần thứ hai của chương (1.2.) sẽ giới thiệu các thuật toán lập lịch với giả định bài toán ở trạng thái tĩnh $(r_j = 0)$, tức tất cả các công việc đều có thể bắt đầu cùng lúc tại thời điểm $t = 0$. Trong đó, thuật toán sắp xếp theo thứ tự công việc là thuật toán cơ bản nhất. Tiếp theo là thuật toán ưu tiên đáo hạn (EDD - Earliest Due Date) và cuối cùng là thuật toán thời gian xử lý ngắn nhất tập trung vào việc tối thiểu hóa tổng thời gian hoàn thành (SPT - Shortest Process Time) và tổng thời gian hoàn thành có trọng số (WSPT - Weighted Shortest Process Time).

Phần tiếp theo của chương (1.3.) sẽ xem xét các bài toán phức tạp hơn, nơi tồn tại các công việc có thời điểm sẵn sàng không đồng nhất $(r_j \neq 0)$. Điều này làm cho bài toán mang tính thực tế hơn trong các quy trình sản xuất khi các công việc thường có khoảng thời gian bắt đầu không đồng nhất tại thời điểm $t=0$. Trong đó, ta sẽ tập trung vào thuật toán chính là thuật toán nhánh cận (branch and bound) - một trong những phương pháp quan trọng giúp hỗ trợ xử lý hầu hết các bài toán có thời điểm sẵn sàng không đồng nhất. Cùng với đó là hai thuật toán bổ trợ khác, bao gồm: thuật toán không ngắt quãng (non-preemptive) và thuật toán ngắt quãng (preemptive). Trong đó thuật toán ngắt quãng cho ta sự linh hoạt cao hơn trong quá trình lập lịch.

Những thuật toán này sẽ giúp các nhà quản lý, các nhà phân tích nghiệp vụ hay chuyên gia tối ưu hóa quy trình tìm được những giải pháp hiệu quả giúp cải thiện hiệu suất và giảm thiểu chi phí trong quá trình sản xuất một cách tối ưu.

Phần lớn kiến thức của chương được tham khảo từ tài liệu \cite{minhhuy}, \cite{inbook}, \cite{pinedo2009planning}, \cite{PMBOK2013}, \cite{PostekZoccaAMPL2024}.

\section{Bài toán trạng thái tĩnh ($r_j = 0$)}
Bài toán tĩnh trong lập lịch cho máy đơn là một trong những bài toán cơ bản và quan trọng trong lĩnh vực quản lý thời gian và tối ưu hóa quy trình. Đặc điểm của bài toán tĩnh là thời điểm sẵn sàng $r_j$ của các công việc đều đồng nhất tại $t=0$, hay $r_j = 0, \: \forall j=\overline{1,n}$ và ký hiệu $r_j$ lúc này không tồn tại trong trường $\beta$ của bài toán.

Trong bối cảnh bài toán ở trạng thái tĩnh, thuật toán sắp xếp theo thứ tự công việc sẽ được trình bày như một cách cơ bản cho bước đầu tiếp cận các thuật toán lập lịch tối ưu hơn. Ở các thuật toán lập lịch tối ưu hơn, các công việc sẽ được sắp xếp sao cho tối thiểu hoá một hàm mục tiêu nhất định, trong đó bao gồm các dạng bài toán: Tối thiểu độ đáo hạn cực đại ($1\|L_{\max}$) hay độ trễ cực đại ($1\|T_{\max}$), tối thiểu tổng thời gian hoàn thành ($1\|\sum C_j$) hay tối thiểu tổng thời gian hoàn thành có trọng số ($1\|\sum w_j C_j$).

Bài toán tĩnh cung cấp một nền tảng lý thuyết vững chắc giúp phát triển các thuật toán xử lý những dạng bài toán lập lịch phức tạp hơn, đồng thời là bước đầu tiên và quan trọng trong việc nghiên cứu và ứng dụng các thuật toán tối ưu trong lĩnh vực quản lý thời gian và tối ưu hoá quy trình.
\subsection{Thuật toán sắp xếp theo thứ tự công việc}
Thuật toán sắp xếp theo thứ tự công việc trong lập lịch cho máy đơn là một thuật toán cơ bản và dễ hiểu. Bằng cách dựa trên số thứ tự công việc được định sẵn, nguyên lý của thuật toán là sắp xếp các công việc sao cho thứ tự của công việc được sắp theo hướng tăng dần hoặc giảm dần.

\begin{vd}
	Minh hoạ trường hợp bài toán với $n=4$ được sắp xếp theo thứ tự giảm dần \eqref{giamdan}.
	
	\begin{figure}[h!]
	\centering
	\begin{tabular}{|c | c c c c |} 
		\hline
		Công việc ($j$) & 4 & 3 & 2 & 1 \\
		\hline\hline
		$p_j$ & 2 & 5 & 1 & 3 \\
		$d_j$ & 6 & 9 & 8 & 3 \\
		\hline
	\end{tabular}
	\caption{\label{giamdan} Trường hợp bài toán được sắp xếp theo thứ tự giảm dần.}
	\end{figure}
\end{vd}
	
\begin{vd}
	Minh hoạ trường hợp bài toán với $n=4$ được sắp xếp theo thứ tự tăng dần \eqref{tangdan}.
	\begin{figure}[h!]
	\centering
	\begin{tabular}{|c | c c c c |} 
		\hline
		Công việc ($j$) & 1 & 2 & 3 & 4 \\
		\hline\hline
		$p_j$ & 3 & 1 & 5 & 2 \\
		$d_j$ & 3 & 8 & 9 & 6 \\
		\hline
	\end{tabular}
	\caption{\label{tangdan} Trường hợp bài toán được sắp xếp theo thứ tự tăng dần.}
	\end{figure}

	Xét \eqref{tangdan} và $p_j$ cho sẵn, ta có thể dễ dàng tính toán được các thông số $C_j, \: S_j, \: W_j, \: F_j, \: L_j, \: T_j, \: E_j$ và thu được bảng sau
\begin{table}[h!]
		\centering
		 \begin{tabular}{|c || c c c c c c c c c c|}
		 \hline
		 Công việc ($j$) & $r_j$ & $p_j$ & $d_j$ & $C_j$ & $S_j$ & $W_j$ & $F_j$ & $L_j$ & $T_j$ & $E_j$ \\
		 \hline
		 1 & 0 & 3 & 3 & 3 & 0 & 0 & 3 & 0 & 0 & 0 \\
		 \hline
		 2 & 0 & 1 & 8 & 4 & 3 & 3 & 4 & -4 & 0 & 4 \\
		 \hline
		 3 & 0 & 5 & 9 & 9 & 4 & 4 & 9 & 0 & 0 & 0 \\
		 \hline
		 4 & 0 & 2 & 6 & 11 & 9 & 9 & 11 & 5 & 5 & 0 \\
		 \hline
		 \end{tabular}
	\end{table}

Vì bài toán ở trạng thái tĩnh nên hiển nhiên $r_j = 0, \: \forall j=\overline{1,4}$. Từ đây ta có thể xác định được
\begin{equation*}
C_{\max} = \sum_{j=1}^4 p_j = 11,
\end{equation*}

\begin{equation*}
	L_{\max} = \max _{1 \leq j \leq 4} \{L_j, 0\} = 5,
\end{equation*}
và
\begin{equation*}
	T_{\max} = \max _{1 \leq j \leq 4} \{T_j, 0\} = 5.
\end{equation*}

Ta tính được trung bình thời gian chờ là
\begin{equation*}
\overline{W} = \frac{\sum_{j=1}^4 W_j}{4} = 4,
\end{equation*}
trung bình chu trình là
\begin{equation*}
\overline{F} = \frac{\sum_{j=1}^4 F_j}{4} = 6.75,
\end{equation*}
trung bình độ đáo hạn là
\begin{equation*}
\overline{L} = \frac{\sum_{j=1}^4 L_j}{4} = 0.25,
\end{equation*}
trung bình độ trễ là
\begin{equation*}
\overline{T} = \frac{\sum_{j=1}^4 T_j}{4} = 1.25,
\end{equation*}
và trung bình độ sớm là
\begin{equation*}
\overline{E} = \frac{\sum_{j=1}^4 E_j}{4} = 1.
\end{equation*}
\end{vd}

Từ lý thuyết và ví dụ minh hoạ trên có thể thấy thuật toán sắp xếp theo thứ tự công việc không yêu cầu tính toán quá phức tạp. Tuy nhiên, còn tồn tại nhiều hạn chế, thuật toán sắp xếp theo thứ tự công việc không xem xét đến các yếu tố cần được tối ưu như độ đáo hạn, độ trễ hay thời gian hoàn thành, do đó có thể không đạt được điều kiện tối ưu như mong muốn và không mang lại hiệu quả cao trong ứng dụng.

Do đó, ta sẽ tập trung vào các thuật toán có khả năng cải thiện mô hình hiệu quả hơn bằng cách tối thiểu độ đáo hạn cực đại $L_{\max}$ ( hay độ trễ cực đại $T_{\max}$) hoặc thuật toán giúp tối thiểu hoá tổng thời gian hoàn thành $\sum C$.
\subsection{Thuật toán ưu tiên đáo hạn}
\textit{Thuật toán ưu tiên đáo hạn}, viết tắt là \textit{EDD (Earliest Due Date)} là một trong những thuật toán phổ biến và hiệu quả trong lập lịch cho máy đơn với mục đích giúp tối thiểu hoá độ đáo hạn cực đại $L_{\max}$ hay độ trễ cực đại $T_{\max}$.

Nguyên lý của thuật toán ưu tiên đáo hạn là ưu tiên xử lý các công việc có thời điểm đáo hạn nhỏ nhất, từ đó sắp xếp các công việc theo thứ tự từ thời điểm đáo hạn nhỏ nhất đến thời điểm đáo hạn lớn nhất. Mục đích là giúp đảm bảo các công việc có thời điểm đáo hạn nhỏ nhất được hoàn thành trước, hạn chế khả năng các công việc bị trễ, từ đó tối thiểu được độ đáo hạn cực đại $L_{\max}$ và độ trễ cực đại $T_{\max}$.

\subsubsection*{Tối thiểu độ đáo hạn cực đại ($1 \| L_{\max}$)}
Với hàm mục tiêu là $L_{\max}$, ta dễ dàng tối thiểu hàm mục tiêu $L_{\max}$ bằng cách sử dụng thuật toán ưu tiên đáo hạn.

\begin{vd}
Giả sử ta có dữ liệu ban đầu như sau \eqref{edd1}.
\begin{figure}[h!]
\centering
	\begin{tabular}{|c | c c c c c |} 
	\hline
	Công việc ($j$) & 1 & 2 & 3 & 4 & 5 \\
	\hline\hline
	$p_j$ & 8 & 10 & 15 & 9 & 5 \\
	$d_j$ & 30 & 9 & 23 & 3 & 11 \\
	\hline
	\end{tabular}
	\caption{\label{edd1} Dữ liệu ban đầu của bài toán minh hoạ thuật toán EDD.}
\end{figure}

Ta dễ dàng tìm được $C_j$ và $L_j$ \eqref{edd2}.
\begin{figure}[h!]
\centering
	\begin{tabular}{|c | c c c c c |} 
	\hline
	Công việc ($j$) & 1 & 2 & 3 & 4 & 5 \\
	\hline\hline
	$p_j$ & 8 & 10 & 15 & 9 & 5 \\
	$C_j$ & 8 & 18 & 33 & 42 & 47 \\
	$d_j$ & 30 & 9 & 23 & 3 & 11 \\
	$L_j$ & -22 & 9 & 10 & 39 & 36 \\
	\hline
	\end{tabular}
	\caption{\label{edd2} Dữ liệu bài toán minh hoạ thuật toán EDD.}
\end{figure}

Ta có
\begin{equation*}
	L_{\max} = \max _{1 \leq j \leq 5} \{L_j, 0\} = 39,
\end{equation*}

Sử dụng thuật toán ưu tiên đáo hạn (EDD) ta được \eqref{edd3}

\begin{figure}[h!]
\centering
	\begin{tabular}{|c | c c c c c |} 
	\hline
	Công việc ($j$) & 4 & 2 & 5 & 3 & 1 \\
	\hline\hline
	$p_j$ & 9 & 10 & 5 & 15 & 8 \\
	$C_j$ & 9 & 19 & 24 & 39 & 47 \\
	$d_j$ & 3 & 9 & 11 & 23 & 30 \\
	$L_j$ & 6 & 10 & 13 & 16 & 17 \\
	\hline
	\end{tabular}
	\caption{\label{edd3} Dữ liệu bài toán sau khi áp dụng thuật toán EDD.}
\end{figure}

Kết quả là
\begin{equation*}
	L_{\max} = \max _{1 \leq j \leq 5} \{L_j, 0\} = 17.
\end{equation*}

Vậy để tối thiểu hàm mục tiêu $L_{\max}$ thì ta cần sắp xếp công việc theo thứ tự $4-2-5-3-1$.
\end{vd}

\subsubsection*{Tối thiểu độ trễ cực đại ($1 \| T_{\max}$)}
Tương tự với hàm mục tiêu $L_{\max}$ với $T_{\max}=\underset{1 \leq j \leq n}{\max} (L_j,0)$, ta cũng dễ dàng tối thiểu hàm mục tiêu $T_{\max}$ bằng cách sử dụng thuật toán ưu tiên đáo hạn như sau, với dữ liệu ban đầu như ở trên, ta tính được

\begin{table}[h!]
	\centering
	\begin{tabular}{|c | c c c c c |} 
	\hline
	Công việc ($j$) & 1 & 2 & 3 & 4 & 5 \\
	\hline\hline
	$p_j$ & 8 & 10 & 15 & 9 & 5 \\
	$C_j$ & 8 & 18 & 33 & 42 & 47 \\
	$d_j$ & 30 & 9 & 23 & 3 & 11 \\
	$L_j$ & -22 & 9 & 10 & 39 & 36 \\
	$T_j$ & 0 & 9 & 10 & 39 & 36 \\
	\hline
	\end{tabular}
\end{table}
Ta có
\begin{equation*}
	T_{\max} = \max _{1 \leq j \leq 5} \{T_j, 0\} = 39,
\end{equation*}

Trong khi đó, ta sử dụng thuật toán ưu tiên đáo hạn thì

\begin{table}[h!]
	\centering
	\begin{tabular}{|c | c c c c c |} 
	\hline
	Công việc ($j$) & 4 & 2 & 5 & 3 & 1 \\
	\hline\hline
	$p_j$ & 9 & 10 & 5 & 15 & 8 \\
	$C_j$ & 9 & 19 & 24 & 39 & 47 \\
	$d_j$ & 3 & 9 & 11 & 23 & 30 \\
	$L_j$ & 6 & 10 & 13 & 16 & 17 \\
	$T_j$ & 6 & 10 & 13 & 16 & 17 \\
	\hline
	\end{tabular}
\end{table}

Ta nhận được
\begin{equation*}
	T_{\max} = \max _{1 \leq j \leq 5} \{T_j, 0\} = 17.
\end{equation*}

Vậy để tối thiểu hàm mục tiêu $T_{\max}$ thì ta cần sắp xếp công việc theo thứ tự $4-2-5-3-1$.
\subsection{Thuật toán thời gian xử lý ngắn nhất}
Một cách tiếp cận tối ưu khác của thuật toán lập lịch cho máy đơn có thể kể đến là \textit{thuật toán thời gian xử lý ngắn nhất}, viết tắt là \textit{SPT (Shortest Process Time)} và \textit{thuật toán thời gian xử lý ngắn nhất có trọng số}, viết tắt là \textit{WSPT (Weighted Shortest Process Time)}.

Ý tưởng của cả hai thuật toán là tập trung vào việc tối thiểu hoá trung bình thời gian chờ $\overline{W}$, đồng thời tối thiểu hoá tổng thời gian hoàn thành $\sum C_j$ hoặc $\sum w_j C_j$ nếu bài toán có tồn tại trọng số $w_j$, bằng cách ưu tiên các công việc có khoảng thời gian xử lý ngắn nhất sẽ được thực hiện trước. 

\subsubsection*{Tối thiểu tổng thời gian hoàn thành ($1 \| \sum C_j$) và tổng thời gian hoàn thành có trọng số ($1 \| \sum w_j C_j$)}
Ta có thể dễ dàng nhận thấy bài toán $1 \| \sum C_j$ chính là trường hợp đặc biệt của bài toán $1 \| \sum w_j C_j$ với trọng số $w_j=1$. Do đó đồng nghĩa thuật toán thời gian xử lý ngắn nhất chính là thuật toán thời gian xử lý ngắn nhất có trọng số $w_j=1$. Kể từ đây, ta chỉ cần tập trung vào bài toán $1\| \sum w_j C_j$.

\begin{nx}[Quy tắc thời gian xử lý ngắn nhất có trọng số]
Với $\frac{w_j}{p_j}$ (hay $\frac{p_j}{w_j}$), nếu bài toán chưa tối ưu thì việc sắp xếp các công việc theo thứ tự giảm dần (hay tăng dần) theo giá trị $\frac{w_j}{p_j}$ (hay $\frac{p_j}{w_j}$) sẽ giúp bài toán tối thiểu được hàm mục tiêu $\sum w_j C_j$.
\end{nx}

\begin{dl}
	Thuật toán thời gian xử lý ngắn nhất và thuật toán thời gian xử lý ngắn nhất có trọng số lần lượt là thuật toán tối ưu cho dạng bài toán $1 \| \sum C_j$ và $1 \| \sum w_j C_j$.
\end{dl}

\begin{proof}

\phantom{text}

\begin{itemize}
\item \textbf{Trường hợp công việc liền kề:}

	Ta gọi tổng thời gian hoàn thành có trọng số của hai công việc liền kề $j-k$ là $S$, ta đặt
	\begin{equation} \label{S}
		S = w_j C_j + w_k C_k = w_j(t+p_j) + w_k(t+p_j+p_k),
	\end{equation}
	trong đó công việc thứ $k$ có thời điểm bắt đầu sau công việc thứ $j$ và thời điểm bắt đầu xử lý công việc $j$ là $t$, tức phương án của bài toán lúc này là $j - k$. \eqref{jk1}
	
	\begin{figure}[h!]
		\centering
		 \begin{tabular}{|c | c c c c c c c |} 
		 \hline
		 Công việc & 1 & 2 & $\ldots$ & $j$ & $k$ & $\ldots$ & $n$ \\
		 \hline\hline
		 $p$ & $p_1$ & $p_2$ & $\ldots$ & $p_j$ & $p_k$ & $\ldots$ & $p_n$ \\
		 $C$ & $C_1$ & $C_2$ & $\ldots$ & $C_j$ & $C_k$ & $\ldots$ & $C_n$ \\
		 \hline
		 \end{tabular}
	\caption{\label{jk1}Phương án $j - k$ của bài toán.}
	\end{figure}
	
	Giả sử phương án này thoả thuật toán WSPT, tức là
	\begin{equation}
	\frac{w_j}{p_j} \leq \frac{w_k}{p_k}.
	\end{equation}
	
	Giả sử ta cần sắp xếp lại vị trí 2 công việc này bằng cách tráo đổi vị trí với nhau thì ta nhận được
	\begin{equation} \label{S'}
		S' = w_k(t+p_k) + w_j(t+p_k+p_j)
	\end{equation}
	với phương án là $k-j$ và thu bảng công việc như sau
	
	\begin{figure}[h!]
		\centering
		 \begin{tabular}{|c | c c c c c c c |} 
		 \hline
		 Công việc & 1 & 2 & $\ldots$ & $k$ & $j$ & $\ldots$ & $n$ \\
		 \hline\hline
		 $p$ & $p_1$ & $p_2$ & $\ldots$ & $p_k$ & $p_j$ & $\ldots$ & $p_n$ \\
		 $C$ & $C_1$ & $C_2$ & $\ldots$ & $C_k$ & $C_j$ & $\ldots$ & $C_n$ \\
		 \hline
		 \end{tabular}
	\caption{Phương án $k - j$ của bài toán.}
	\end{figure}

	Mục đích của thuật toán là tối thiểu hoá tổng thời gian hoàn thành của bài toán, vậy nên
	\begin{equation} \label{s>s'}
		S > S'
	\end{equation}
	Từ \eqref{S}, \eqref{S'} và \eqref{s>s'} ta được
        \begin{equation*}
        \begin{array}{c c c c}
		& w_j(t+p_j) + w_k(t+p_j+p_k) &>& w_k(t+p_k) + w_j(t+p_k+p_j) \\
		\\
		\Leftrightarrow & w_jt + w_jp_j + w_kt + w_k p_j + w_kp_k &>& w_k t + w_k p_k + w_j t + w_j p_k + w_j p_j \\
		\\
		\Leftrightarrow & w_k p_j &>& w_j p_k \\
		\\
		\Leftrightarrow & \scalebox{1.5}{$\frac{w_k}{p_k}$} &>& \scalebox{1.5}{$\frac{w_j}{p_j}$} \\
        \end{array}
        \end{equation*}
		Vậy nếu muốn $S'<S$ thì \scalebox{1.3}{$\frac{w_j}{p_j}$} < \scalebox{1.3}{$\frac{w_k}{p_k}$} hay \scalebox{1.3}{$\frac{p_j}{w_j}$} > \scalebox{1.3}{$\frac{p_k}{w_k}$} (đpcm).

\phantom{text}

\item \textbf{Trường hợp công việc không liền kề:}

Giả sử công việc thứ $k$ có thời điểm bắt đầu sau một dãy các công việc khác. Ta lấy công việc thứ $j$ là công việc cần xét, tức phương án của bài toán lúc này là $j \rightarrow j+1 \rightarrow \ldots \rightarrow k-1 \rightarrow k$. \eqref{jk1}

\begin{figure}[h!]
	\centering
	 \begin{tabular}{|c | c c c c c c c c c c |} 
	 \hline
	 Công việc & 1 & 2 & $\ldots$ & $j$ & $j+1$ & $\ldots$ & $k-1$ & $k$ & $\ldots$ & $n$ \\
	 \hline\hline
	 $p$ & $p_1$ & $p_2$ & $\ldots$ & $p_j$ & $p_{j+1}$ & $\ldots$ & $p_{k-1}$ & $p_k$ & $\ldots$ & $p_n$ \\
	 $C$ & $C_1$ & $C_2$ & $\ldots$ & $C_j$ & $C_{j+1}$ & $\ldots$ & $C_{k-1}$ & $C_k$ & $\ldots$ & $C_n$ \\
	 \hline
	 \end{tabular}
\caption{\label{jk1}Phương án $j \rightarrow j+1 \rightarrow \ldots \rightarrow k-1 \rightarrow k$ của bài toán.}
\end{figure}

Từ chứng minh của công việc liền kề, ta thấy rằng, công việc $j$ và $j+1$ chỉ hoán đổi vị trí khi và chỉ khi $$\scalebox{1.3}{$\frac{w_{j+1}}{p_{j+1}}$} < \scalebox{1.3}{$\frac{w_j}{p_j}$}$$ hay $$\scalebox{1.3}{$\frac{p_j}{w_j}$} > \scalebox{1.3}{$\frac{p_{j+1}}{w_{j+1}}$}.$$

Nếu tồn tại một công việc thứ 3, giả sử $j+2$, thì công việc $j$ và $j+2$ chỉ hoán đổi khi và chỉ khi $$\scalebox{1.3}{$\frac{w_{j+2}}{p_{j+2}}$} < \scalebox{1.3}{$\frac{w_{j+1}}{p_{j+1}}$} < \scalebox{1.3}{$\frac{w_j}{p_j}$}$$ hay $$\scalebox{1.3}{$\frac{p_j}{w_j}$} > \scalebox{1.3}{$\frac{p_{j+1}}{w_{j+1}}$} > \scalebox{1.3}{$\frac{p_{j+2}}{w_{j+2}}$}.$$

Vậy hiển nhiên, chuỗi công việc $j \rightarrow j+1 \rightarrow \ldots \rightarrow k-1 \rightarrow k$ sẽ được sắp xếp theo chiều tăng dần dựa trên giá trị phân thức $\scalebox{1.3}{$\frac{p}{w}$}$ hoặc theo chiều giảm dần dựa trên phân thức $\scalebox{1.3}{$\frac{w}{p}$}$. (đpcm)

\end{itemize}

% \textbf{Trường hợp công việc không liền kề:}

	% Ta gọi tổng thời gian hoàn thành có trọng số của hai công việc không liền kề $$j \rightarrow j+1 \rightarrow \ldots \rightarrow k-1 \rightarrow k$$ là $S$, ta đặt
	% \begin{equation} \label{kolienke1}
	% 	\begin{array}{c c c}
	% 	S &=& w_j C_j + w_{j+1} C_{j+1} + \ldots + w_{k-1} C_{k-1} + w_k C_k \\
	% 	&=& w_j(t+p_j) + w_{j+1} (t + p_j + p_{j+1}) + \ldots \\
	% 	&& + w_{k-1}(t + p_j  + p_{j+1} + \ldots +p_{k-1}) \\
	% 	&& + w_k(t + p_j + p_{j+1} + \ldots +p_{k-1} + p_k),
	% 	\end{array}
	% \end{equation}

	
	% Giả sử phương án này thoả thuật toán WSPT, tức là
	% \begin{equation}
	% \frac{w_j}{p_j} \leq \frac{w_k}{p_k}.
	% \end{equation}
	
	% Giả sử ta cần sắp xếp lại vị trí 2 công việc này bằng cách tráo đổi vị trí với nhau thì ta nhận được
	
	% \begin{equation} \label{kolienke2}
	% 	\begin{array}{c c c}
	% 	S' &=& w_k C_k + w_{j+1} C_{j+1} + \ldots + w_{k-1} C_{k-1} + w_j C_j\\

	% 	&=& w_k(t+p_k) + w_{j+1} (t + p_k + p_{j+1}) + \ldots \\
	% 	&& + w_{k-1}(t + p_k  + p_{j+1} + \ldots +p_{k-1}) \\
	% 	&& + w_j(t + p_k + p_{j+1} + \ldots +p_{k-1} + p_j),
	% 	\end{array}
	% \end{equation}
	% với phương án là $k \rightarrow j+1 \rightarrow \ldots \rightarrow k-1 \rightarrow j$ và thu bảng công việc như sau
	
	% \begin{figure}[h!]
	% 	\centering
	% 	 \begin{tabular}{|c | c c c c c c c c c c |} 
	% 	 \hline
	% 	 Công việc & 1 & 2 & $\ldots$ & $k$ & $j+1$ & $\ldots$ & $k-1$ & $j$ & $\ldots$ & $n$ \\
	% 	 \hline\hline
	% 	 $p$ & $p_1$ & $p_2$ & $\ldots$ & $p_k$ & $p_{j+1}$ & $\ldots$ & $p_{k-1}$ & $p_j$ & $\ldots$ & $p_n$ \\
	% 	 $C$ & $C_1$ & $C_2$ & $\ldots$ & $C_k$ & $C_{j+1}$ & $\ldots$ & $C_{k-1}$ & $C_j$ & $\ldots$ & $C_n$ \\
	% 	 \hline
	% 	 \end{tabular}
	% \caption{Phương án $k \rightarrow j+1 \rightarrow \ldots \rightarrow k-1 \rightarrow j$ của bài toán.}
	% \end{figure}

	% Mục đích của thuật toán là tối thiểu hoá tổng thời gian hoàn thành của bài toán, vậy nên
	% \begin{equation} \label{kolienke3}
	% 	S > S'
	% \end{equation}
	% Từ \eqref{kolienke1}, \eqref{kolienke2} và \eqref{kolienke3} ta được
    %     \begin{equation*}
    %     \begin{array}{c c c c}
	% 	& w_j(t+p_j) + w_{j+1} (t + p_j + p_{j+1}) + \ldots && w_k(t+p_k) + w_{j+1} (t + p_k + p_{j+1}) + \ldots \\
	% 	& + w_{k-1}(t + p_j  + p_{j+1} + \ldots +p_{k-1}) &>& + w_{k-1}(t + p_k  + p_{j+1} + \ldots +p_{k-1})\\
	% 	& + w_k(t + p_j + p_{j+1} + \ldots +p_{k-1} + p_k) &&  + w_j(t + p_k + p_{j+1} + \ldots +p_{k-1} + p_j)
	% 	\\
	% 	\Leftrightarrow & w_{j+1}p_j + \ldots + w_{k-1}p_j + &>& w_{j+1}p_k + \ldots + w_{k-1}p_k + \\
	% 	& w_kp_j + w_kp_{j+1} + \ldots + w_kp_{k-1} && w_jp_k + w_jp_{j+1} + \ldots + w_jp_{k-1} \\
    %     \end{array}
    %     \end{equation*}
	% 	\begin{equation*}
	% 		\Leftrightarrow
	% 		  \begin{cases}
	% 			\begin{array}{c c c}
	% 				w_k (p_{j+1}+\ldots + p_{k-1}) &>& w_j(p_{j+1}+\ldots + p_{k-1}) \\
	% 				p_j(w_{j+1}+\ldots + w_{k-1}) &>& p_k (w_{j+1}+\ldots + w_{k-1}) \\
	% 				w_kp_j &>& w_jp_k
	% 			\end{array}
	% 		  \end{cases}       
	% 	  \end{equation*}
	% 	\begin{equation*}
	% 		\Leftrightarrow
	% 		  \begin{cases}
	% 			\begin{array}{c c c}
	% 				w_k &>& w_j \\
	% 				p_j &>& p_k \\
	% 				w_kp_j &>& w_jp_k
	% 			\end{array}
	% 		  \end{cases}       
	% 	  \end{equation*}
		
	% 	Ta luôn ưu tiên công việc có mức độ ưu tiên (tức trọng số $w$) lớn nhất và thời gian xử lý $p$ nhỏ nhất nên $p_j > p_k$ và $w_k > w_j$ là luôn đúng.
		
	% 	Ta có $p_u > 0$, $ p_k>0$, $p_j > 0$, $w_u>0$, $w_j>0$, $w_k >0$, vậy
	% 	\begin{equation}
	% 		\scalebox{1.5}{$\frac{w_k}{p_k}$} > \scalebox{1.5}{$\frac{w_j}{p_j}$} \text{ (đpcm).}
	% 	\end{equation}
\end{proof}

\begin{vd}[Tối thiểu tổng thời gian hoàn thành có trọng số ($1 \| \sum w_j C_j$)]
Ta có bảng công việc sau \eqref{vdwspt}

\begin{figure}[h!]
	\centering
	\begin{tabular}{|c | c c c c |} 
	\hline
	Công việc ($j$) & 1 & 2 & 3 & 4 \\
	\hline\hline
	$p_j$ & 12 & 4 & 9 & 10 \\
	$C_j$ & 12 & 16 & 25 & 35 \\
	$W_j$ & 0 & 12 & 16 & 25 \\
	\hline
	\end{tabular}
\caption{\label{vdwspt} Dữ liệu bài toán minh hoạ thuật toán WSPT.}
\end{figure}

Từ đây ta có
\begin{equation*}
\overline{W}=\frac{\sum_{j=1}^{4}W_j}{4} = 13.25.
\end{equation*}
Áp dụng quy tắc quá trình ngắn nhất có trọng số với trọng số $w_j=1$, ta được bảng công việc sau
\begin{table}[h!]
	\centering
	\begin{tabular}{|c | c c c c |} 
	\hline
	Công việc ($j$) & 2 & 3 & 4 & 1 \\
	\hline\hline
	$p_j$ & 4 & 9 & 10 & 12 \\
	$C_j$ & 4 & 13 & 23 & 35 \\
	$W_j$ & 0 & 4 & 13 & 23 \\
	\hline
	\end{tabular}
\end{table}

Ta có
\begin{equation*}
\overline{W}=\frac{\sum_{j=1}^{4}W_j}{4} = 10.
\end{equation*}

Vậy để tối thiểu hàm mục tiêu $\sum w_j C_j$ thì ta cần sắp xếp công việc theo thứ tự $2-3-4-1$.
\end{vd}

\subsubsection*{Tối thiểu tổng thời gian hoàn thành có trọng số với ràng buộc có thứ tự ($1 | prec | \sum w_j C_j$)}
Bài toán tối thiểu tổng thời gian hoàn thành có trọng số với ràng buộc có thứ tự, ký hiệu là $1|prec|\sum w_j C_j$, là một trong những bài toán quan trọng trong lý thuyết lập lịch cho máy đơn và là bài toán mở rộng thêm ràng buộc có thứ tự của bài toán tối thiểu tổng thời gian hoàn thành có trọng số thông thường.

Bài toán $1|prec|\sum w_j C_j$ tồn tại những công việc đòi hỏi phải hoàn thành trước khi công việc khác được bắt đầu, hay còn gọi là công việc tiền nhiệm (predecessor) và công việc kế nhiệm (successor). Ở đây, ta chỉ quan tâm dạng dây chuyền (chains), tức trường hợp bài toán có mỗi công việc tồn tại tối đa một tiền nhiệm và một kế nhiệm.

\begin{dn}
Cho một tập hợp gồm $n$ công việc ($\{J_1, J_2, …, J_n\}$) cần được xử lý trên một máy đơn thì lúc này ta nhận được hệ số $p$ ($p$-factor) được định nghĩa bằng công thức sau
\begin{equation}
	\underset{1 \leq j \leq n}{\text{hệ số }p} = \frac{\sum_{j=1}^n w_j}{\sum_{j=1}^n p_j}
\end{equation}
\end{dn}

Giả sử trên tập hợp gồm $n$ công việc ($\{J_1, J_2, …, J_n\}$), trong đó tồn tại dây chuyền $I$ với
\begin{equation*}
1 - 2 - \ldots - k,
\end{equation*}
và dây chuyền $II$ với
\begin{equation*}
k+1 - k+2 - \ldots - n.
\end{equation*}
Thì ta nhận được hệ số $p$ của dây chuyền $I$ là
\begin{equation}
	\underset{1 \leq j \leq k}{\text{hệ số }p} = \frac{\sum_{j=1}^k w_j}{\sum_{j=1}^k p_j},
\end{equation}
và hệ số $p$ của dây chuyền $II$ là
\begin{equation}
	\underset{k+1 \leq j \leq n}{\text{hệ số }p} = \frac{\sum_{j=k+1}^n w_j}{\sum_{j=k+1}^n p_j}.
\end{equation}
Từ đây, ta có định lý sau
\begin{dl} \label{daychuyen}
	Nếu $\underset{1 \leq j \leq k}{\text{hệ số }p} > \underset{k+1 \leq j \leq n}{\text{hệ số }p}$ thì thuật toán sắp xếp tối ưu của bài toán sẽ bắt đầu từ dây chuyền $I$ rồi đến dây chuyền $II$ và ngược lại.
\end{dl}

\begin{proof}
	Đặt $S_I$ là tổng thời gian hoàn thành có trọng số của dây chuyền thứ $I$ với
	\begin{equation}
		S_I = w_1 p_1 + w_2 p_2 + \ldots + w_k \sum_{j=1}^k p_j,
	\end{equation}
	và $S_{II}$ là tổng thời gian hoàn thành có trọng số của dây chuyền thứ $II$ với
	\begin{equation}
		S_{II} = w_{k+1} \sum_{j=1}^{k+1} p_j + \ldots + w_n \sum_{j=1}^{n} p_j.
	\end{equation}
	Ta gọi tổng thời gian hoàn thành có trọng số ban đầu là $S_A$ với
	\begin{equation} \label{SA}
		S_A = S_I + S_{II} = w_1 p_1 + w_2 (p_1 + p_2) + \ldots + w_k \sum_{j=1}^k p_j + w_{k+1} \sum_{j=1}^{k+1} p_j + w_{k+2} \sum_{j=1}^{k+2} p_j + \ldots + w_n \sum_{j=1}^{n} p_j
	\end{equation}
	Hoán đổi vị trí của $S_I$ và $S_{II}$ trên sơ đồ Gantt ta được
	\begin{equation}
		S_I^{'} = w_{k+1} p_{k+1} + w_{k+2}(p_{k+1} + p_{k+2}) + \ldots + w_n \sum_{j=k+1}^{n} p_j,
	\end{equation}
	và
	\begin{equation}
		S_{II}^{'} = w_1(\sum_{j=k+1}^{n}p_j+p_1) + w_2(\sum_{j=k+1}^{n}p_j+p_1+p_2) + \ldots + w_k\sum_{j=1}^{n} p_j.
	\end{equation}
	Ta gọi tổng thời gian hoàn thành có trọng số sau khi hoán đổi là $S_B$ với
	\begin{equation} \label{SB}
		\begin{array}{c c c}
		S_B &=& S_I^{'} + S_{II}^{'} \\
		&=& w_{k+1} p_{k+1} + w_{k+2}(p_{k+1} + p_{k+2}) + \ldots + w_n \sum_{j=k+1}^{n} p_j \\
		&& + w_1(\sum_{j=k+1}^{n}p_j+p_1) + w_2(\sum_{j=k+1}^{n}p_j+p_1+p_2) + \ldots + w_k\sum_{j=1}^{n} p_j
		\end{array}
	\end{equation}
	Giả sử ta xét trường hợp
	\begin{equation} \label{SA<SB}
		S_A < S_B
	\end{equation}
	Từ \eqref{SA}, \eqref{SB} và \eqref{SA<SB} ta được
	\begin{equation*}
	\begin{array}{c c c c}
	& w_1 p_1 + w_2 (p_1 + p_2)  && w_{k+1} p_{k+1} + w_{k+2}(p_{k+1} + p_{k+2}) \\

	& + \ldots + w_k \sum_{j=1}^k p_j + w_{k+1} \sum_{j=1}^{k+1} p_j &<& + \ldots + w_n \sum_{j=k+1}^{n} p_j \\
	
	&+ w_{k+2} \sum_{j=1}^{k+2} p_j  + \ldots + w_n \sum_{j=1}^{n} p_j && + w_1(\sum_{j=k+1}^{n}p_j+p_1) \\

	&&& + w_2(\sum_{j=k+1}^{n}p_j+p_1+p_2)\\

	&&& + \ldots + w_k\sum_{j=1}^{n} p_j \\
	\\
	\Leftrightarrow & -(w_1 \sum_{j=k+1}^{n}p_j + \ldots + w_k \sum_{j=k+1}^{n}p_j) &<& 0 \\
	&+ w_{k+1} \sum_{j=1}^{k}p_j + \ldots + w_n \sum_{j=1}^{k}p_j && \\
	\\
	\Leftrightarrow & -(\sum_{j=1}^{k}w_j \sum_{j=k+1}^{n}p_j) + \sum_{j=k+1}^{n}w_j\sum_{j=1}^{k}p_j &<& 0 \\
	\\
	\Leftrightarrow & \sum_{j=k+1}^{n}w_j\sum_{j=1}^{k}p_j &<& \sum_{j=1}^{k}w_j \sum_{j=k+1}^{n}p_j \\
	\\
	\Leftrightarrow & \scalebox{1.5}{$\frac{\sum_{j=k+1}^{n}w_j}{\sum_{j=k+1}^{n}p_j}$} &<& \scalebox{1.5}{$\frac{\sum_{j=1}^{k}w_j}{\sum_{j=1}^{k}p_j}$} \\
	\\
	\Leftrightarrow & \underset{k+1 \leq j \leq n}{\text{hệ số }p} &<& \underset{1 \leq j \leq k}{\text{hệ số }p} \\
	\end{array}
	\end{equation*}
	Tương tự, xét trường hợp $S_A > S_B$ ta được $\underset{k+1 \leq j \leq n}{\text{hệ số }p} > \underset{1 \leq j \leq k}{\text{hệ số }p}$ (đpcm).
\end{proof}

Do đặc tính của bài toán $1|prec|\sum w_jC_j$ cho phép ta có thể chuyển giao qua lại giữa các dây chuyền miễn vẫn đảm bảo ràng buộc thứ tự của các công việc. Từ đặc tính này ta có thể cải thiện định lý \eqref{daychuyen} giúp cho ra giải pháp tối ưu hơn.

Ý tưởng cải thiện là tiếp tục phân nhỏ các dây chuyền sẵn có, từ đó tìm ra hệ số $p$ tối ưu trên mỗi dây chuyền, đánh giá các giá trị của hệ số $p$ tối ưu sẽ giúp ta chuyển giao qua lại giữa các dây chuyền một cách hiệu quả từ đó tối thiểu hoá thời gian hoàn thành.

\begin{dn}[Hệ số $p$ tối ưu]
Ta gọi $\underset{1 \leq j \leq l^*}{\text{hệ số }p}$ là hệ số $p$ tối ưu của dây chuyền $1-2-\ldots -k$, ký hiệu $p(1,\ldots,k)$, được định nghĩa bằng công thức sau
\begin{equation}
	\underset{1 \leq j \leq l^*}{\text{hệ số }p}= \frac{\sum_{j=1}^{l^*}w_j}{\sum_{j=1}^{l^*}p_j} = \underset{1 \leq l \leq k}{\max}\Biggl(\frac{\sum_{j=1}^{l}w_j}{\sum_{j=1}^{l}p_j}\Biggl).
\end{equation}
Tương tự với các dây chuyền còn lại.
\end{dn}

Giả sử trên tập hợp gồm $n$ công việc ($\{J_1, J_2, …, J_n\}$), trong đó tồn tại dây chuyền $I$ với
\begin{equation*}
1 - 2 - \ldots - k
\end{equation*}
và dây chuyền $II$ với
\begin{equation*}
k+1 - k+2 - \ldots - n.
\end{equation*}
Ta có định lý sau
\begin{dl}[Tính bất định]
	Nếu ta xác định được $p(1,\ldots,k)$ từ dây chuyền $I$ thì $1,\ldots,l^*$ chính là chuỗi công việc tối ưu của dây chuyền $I$ và chuỗi kế nhiệm phải là chuỗi công việc $p(k+1,\ldots,n)$ của dây chuyền $II$. 
\end{dl}

\begin{proof}
	Giả sử ta có dây chuyền $S$ có thứ tự công việc là 
	\begin{equation*}
	1,\ldots,u,v,u+1,\ldots,l^*
	\end{equation*}
	trong đó $v$ là phần tử của dây chuyền khác.
	Ta có dây chuyền $S'$ với chuỗi công việc
	\begin{equation*}
		v,1,\ldots,l^*
	\end{equation*}
	và $S''$ với chuỗi công việc
	\begin{equation*}
		1,\ldots,l^*,v
	\end{equation*}
	Do ta có $1,\ldots,u,u+1,\ldots,l^*$ là chuỗi công việc tối ưu, vì thế
	\begin{equation} \label{1}
		\sum_{j=1}^{u}\biggl(\frac{w_j}{p_j}\biggl) > \sum_{j=u+1}^{l^*}\biggl(\frac{w_j}{p_j}\biggl)
	\end{equation}
	TH1.
	Nếu $S' < S$ và $S''>S$ thì lần lượt có các bất đẳng thức sau
	\begin{equation} \label{2}
		\frac{w_v}{p_v} > \sum_{j=1}^{u}\biggl(\frac{w_j}{p_j}\biggr)
	\end{equation}
	và
	\begin{equation} \label{3}
		\frac{w_v}{p_v} > \sum_{j=u+1}^{l^*}\biggl(\frac{w_j}{p_j}\biggr)
	\end{equation}
	Từ \eqref{1}, \eqref{2} và \eqref{3} ta được
	\begin{equation}
		\frac{w_v}{p_v} > \sum_{j=1}^{u}\biggl(\frac{w_j}{p_j}\biggl) > \sum_{j=u+1}^{l^*}\biggl(\frac{w_j}{p_j}\biggl) \quad \text{(thoả).}
	\end{equation}
	TH2.
	Nếu $S' > S$ và $S'' < S$ thì lần lượt có các bất đẳng thức sau
	\begin{equation} \label{4}
		\frac{w_v}{p_v} < \sum_{j=1}^{u}\biggl(\frac{w_j}{p_j}\biggr)
	\end{equation}
	và
	\begin{equation} \label{5}
		\frac{w_v}{p_v} < \sum_{j=u+1}^{l^*}\biggl(\frac{w_j}{p_j}\biggr)
	\end{equation}
	Từ \eqref{1}, \eqref{4} và \eqref{5} ta được
	\begin{equation}
		 \sum_{j=1}^{u}\biggl(\frac{w_j}{p_j}\biggl) > \sum_{j=u+1}^{l^*}\biggl(\frac{w_j}{p_j}\biggl) > \frac{w_v}{p_v} \quad \text{(thoả).}
	\end{equation}
	TH3.
	Nếu $S' > S$ và $S'' > S$ thì lần lượt có các bất đẳng thức sau
	\begin{equation} \label{6}
		\frac{w_v}{p_v} < \sum_{j=1}^{u}\biggl(\frac{w_j}{p_j}\biggr)
	\end{equation}
	và
	\begin{equation} \label{7}
		\frac{w_v}{p_v} > \sum_{j=u+1}^{l^*}\biggl(\frac{w_j}{p_j}\biggr)
	\end{equation}
	Từ \eqref{1}, \eqref{6} và \eqref{7} $\implies$ vô lý. \\
	TH4.
	Nếu $S' < S$ và $S'' < S$ thì lần lượt có các bất đẳng thức sau
	\begin{equation} \label{8}
		\frac{w_v}{p_v} > \sum_{j=1}^{u}\biggl(\frac{w_j}{p_j}\biggr)
	\end{equation}
	và
	\begin{equation} \label{9}
		\frac{w_v}{p_v} < \sum_{j=u+1}^{l^*}\biggl(\frac{w_j}{p_j}\biggr)
	\end{equation}
	Từ \eqref{1}, \eqref{8} và \eqref{9} $\implies$ vô lý. \\
	Vậy luôn tồn tại $S'<S$ hoặc $S''<S$ (đpcm).
\end{proof}

\begin{vd}[Tối thiểu tổng thời gian hoàn thành có trọng số với ràng buộc có thứ tự ($1 | prec | \sum w_j C_j$)]
Ta có bảng công việc sau \eqref{vdwsptpre}

\begin{figure}[h!]
	\centering
	\begin{tabular}{|c | c c c | c c |} 
	\hline
	Công việc ($j$) & 1 & 2 & 3 & 4 & 5 \\
	\hline\hline
	$p_j$ & 5 & 18 & 19 & 3 & 14 \\
	$w_j$ & 13 & 14 & 6 & 7 & 10 \\
	\hline
	\end{tabular}
\caption{\label{vdwsptpre} Dữ liệu minh hoạ bài toán $1 | prec | \sum w_j C_j$.}
\end{figure}

Trong đó dây chuyền thứ $I$ là $$1-2-3$$ và dây chuyền thứ $II$ là $$4-5.$$
ta xác định hệ số $p$ của dây chuyền thứ nhất bằng công thức $$\text{Hệ số }p=\frac{\sum w_j}{\sum p_j}$$

\begin{table}[h!]
	\centering
	\begin{tabular}{|c | c c c |} 
	\hline
	Chuỗi $I$ & 1 & 1-2 & 1-2-3 \\
	\hline\hline
	Hệ số $p$ & 2.6 & 1.17 & 0.78 \\
	\hline
	\end{tabular}
\end{table}
Ta có chuỗi $I$ có $$
	\underset{1 \leq j \leq l^*}{\text{hệ số }p}= \frac{\sum_{j=1}^{l^*}w_j}{\sum_{j=1}^{l^*}p_j} = \underset{1 \leq l \leq k}{\max}\Biggl(\frac{\sum_{j=1}^{l}w_j}{\sum_{j=1}^{l}p_j}\Biggl)=2.6.$$

\begin{table}[h!]
	\centering
	\begin{tabular}{|c | c c |} 
	\hline
	Chuỗi $II$ & 4 & 4-5 \\
	\hline\hline
	Hệ số $p$ & 2.33 & 1 \\
	\hline
	\end{tabular}
\end{table}
Ta có chuỗi $II$ có $$
	\underset{1 \leq j \leq l^*}{\text{hệ số }p}= \frac{\sum_{j=1}^{l^*}w_j}{\sum_{j=1}^{l^*}p_j} = \underset{1 \leq l \leq k}{\max}\Biggl(\frac{\sum_{j=1}^{l}w_j}{\sum_{j=1}^{l}p_j}\Biggl)=2.33.$$

Vì $2.6>2.3$ nên ta chọn chuỗi $I$ với công việc 1.

\begin{table}[h!]
	\centering
	\begin{tabular}{|c | c c |} 
	\hline
	Chuỗi $I$ & 2 & 2-3 \\
	\hline\hline
	Hệ số $p$ & 0.77 & 0.54 \\
	\hline
	\end{tabular}
\end{table}
Ta có chuỗi $I$ có $$
	\underset{1 \leq j \leq l^*}{\text{hệ số }p}= \frac{\sum_{j=1}^{l^*}w_j}{\sum_{j=1}^{l^*}p_j} = \underset{1 \leq l \leq k}{\max}\Biggl(\frac{\sum_{j=1}^{l}w_j}{\sum_{j=1}^{l}p_j}\Biggl)=0.77.$$

Tiếp tục so với chuỗi $II$ ta có $2.33>0.77$ nên ta chọn chuỗi $II$ với 4.
Ta được chuỗi $$1-4-\ldots-\ldots-\ldots$$

\begin{table}[h!]
	\centering
	\begin{tabular}{|c | c |} 
	\hline
	Chuỗi $II$ & 5 \\
	\hline\hline
	Hệ số $p$ & 0.71 \\
	\hline
	\end{tabular}
\end{table}

Ta có chuỗi $II$ có $$
	\underset{1 \leq j \leq l^*}{\text{hệ số }p}= \frac{\sum_{j=1}^{l^*}w_j}{\sum_{j=1}^{l^*}p_j} = \underset{1 \leq l \leq k}{\max}\Biggl(\frac{\sum_{j=1}^{l}w_j}{\sum_{j=1}^{l}p_j}\Biggl)=0.71.$$

Ta so với chuỗi $I$ được $0.77>0.71$ nên ta chọn chuỗi $I$ với 2. Ta được chuỗi $$1-4-2-\ldots-\ldots$$

\begin{table}[h!]
	\centering
	\begin{tabular}{|c | c |} 
	\hline
	Chuỗi $I$ & 3 \\
	\hline\hline
	Hệ số $p$ & 0.31 \\
	\hline
	\end{tabular}
\end{table}
Ta so với chuỗi $II$ được $0.71>0.31$ nên ta chọn chuỗi $II$ với 5. Ta được chuỗi $$1-4-2-5-\ldots$$

Vì không còn công việc nào nên vị trí cuối cùng là công việc 3.

Vậy phương án tối ưu của bài toán là $$1-4-2-5-3$$

\begin{table}[h!]
	\centering
	\begin{tabular}{|c | c c c c c |} 
	\hline
	Công việc ($j$) & 1 & 4 & 2 & 5 & 3 \\
	\hline\hline
	$p_j$ & 5 & 3 & 18 & 14 & 19 \\
	$C_j$ & 5 & 8 & 26 & 40 & 59 \\
	$w_j$ & 13 & 7 & 14 & 10 & 6 \\
	$W_j$ & 0 & 5 & 8 & 26 & 40 \\
	\hline
	\end{tabular}
\end{table}

Và trung bình thời gian chờ
\begin{equation*}
\overline{W} = \frac{\sum_{j=1}^5 W_j}{5} = 15.8.
\end{equation*}

\end{vd}
\section{Bài toán có thời điểm sẵn sàng không đồng nhất ($r_j \neq 0$)}
Bài toán lập lịch máy đơn với thời điểm sẵn sàng không đồng nhất là một dạng bài toán có ràng buộc phức tạp nhưng lại vô cùng quan trọng trong thực tế. Trong dạng này, mỗi công việc có một thời điểm sẵn sàng $r_j$ khác nhau, tức các công việc lúc này không thể được sắp xếp một cách tự do mà phải thoả điều kiện sao cho thời điểm bắt đầu công việc thứ $j$ không được sớm hơn thời điểm sẵn sàng cho trước. Điều này thêm vào một lớp phức tạp cho quá trình lập lịch, đòi hỏi phải xem xét không chỉ thứ tự thực hiện các công việc mà còn cả thời điểm bắt đầu sao cho khả thi.

Tồn tại một thuật toán giúp tiếp cận bài toán một cách hiệu quả, đó là thuật toán nhánh cận (branch and bound) cùng với hai thuật toán hậu phân nhánh, đó là thuật toán không ngắt quãng (non-preemptive) và thuật toán ngắt quãng (preemptive). Trong đó, thuật toán ngắt quãng cho thấy sự hiệu quả và linh hoạt hơn khi áp dụng vào thực tiễn, cũng như đưa ra giải pháp tối ưu hơn.

\subsection*{Thuật toán không ngắt quãng}
Nguyên lý của \textit{thuật toán không ngắt quãng (non-preemptive)} dựa trên thuật toán ưu tiên đáo hạn và xử lý các thời điểm sẵn sàng $r_j$ bằng các quãng nghỉ nhàn rỗi, từ đó cộng dồn và làm tăng tổng thời gian hoàn thành $C_{\max}$.

Ưu điểm của thuật toán là dễ triển khai và đơn giản nhưng nhược điểm và hạn chế của thuật toán khiến cho tổng thời gian hoàn thành $C_{\max}$ tăng, từ đó giảm hiệu suất tổng thể.
\begin{vd} \label{kongatquang}
Minh hoạ trường hợp bài toán toán với $n=4$ áp dụng thuật toán không ngắt quãng.
Ta có bảng công việc \eqref{vdnonprmp}

\begin{figure}[h!]
	\centering
		\begin{tabular}{|c | c c c c |} 
		\hline
		Công việc ($j$) & 1 & 2 & 3 & 4 \\
		\hline\hline
		$p_j$ & 3 & 1 & 5 & 2 \\
		\hline
		$d_j$ & 3 & 8 & 9 & 6 \\
		\hline
		$r_j$ & 0 & 7 & 3 & 3 \\
		\hline
		\end{tabular}
\caption{\label{vdnonprmp} Dữ liệu minh hoạ bài toán không ngắt quãng.}
\end{figure}

Sử dụng thuật toán ưu tiên đáo hạn ta được phương án \eqref{vdnonprmp2}
\begin{figure}[h!]
	\centering
		\begin{tabular}{|c | c c c c |} 
		\hline
		Công việc ($j$) & 1 & 4 & 2 & 3 \\
		\hline\hline
		$p_j$ & 3 & 2 & 1 & 5 \\
		\hline
		$C_j$ & 3 & 5 & 6 & 11 \\
		\hline
		$d_j$ & 3 & 6 & 8 & 9 \\
		\hline
		$r_j$ & 0 & 3 & 7 & 3 \\
		\hline
		$L_j$ & 0 & -1 & -2 & 2 \\
		\hline
		\end{tabular}
\caption{\label{vdnonprmp2} Dữ liệu minh hoạ bài toán không ngắt quãng.}
\end{figure}

\begin{figure}[h!]
\centering
\begin{ganttchart}[
    hgrid,
    vgrid,
    y unit title=.5cm,
    title/.style={draw=none, fill=none},
    include title in canvas=false
]{0}{11}
\gantttitlelist{0,...,11}{1} \\
\ganttmilestone{$r_1$}{0} \\
\ganttlinkedbar{$J_1$}{1}{3} \\
\ganttlinkedmilestone{$r_3,\:r_4$}{3} \\
\ganttlinkedbar{$J_4$}{4}{5} \\
\ganttlinkedbar{$J_2$}{6}{6} \\
\ganttlinkedmilestone{$r_2$}{7} \\
\ganttlinkedbar{$J_3$}{7}{11}
\end{ganttchart}
\caption{\label{ganttnonprmp} Sơ đồ Gantt của bài toán khi chưa áp dụng thuật toán không ngắt quãng.}
\end{figure}
\begin{figure}[h!]
\centering
\begin{ganttchart}[
    hgrid,
    vgrid,
    y unit title=.5cm,
    title/.style={draw=none, fill=none},
    include title in canvas=false
]{0}{13}
\gantttitlelist{0,...,13}{1} \\
\ganttmilestone{$r_1$}{0} \\
\ganttlinkedbar{$J_1$}{1}{3} \\
\ganttlinkedmilestone{$r_3,\:r_4$}{3} \\
\ganttlinkedbar{$J_4$}{4}{5} \\
\ganttlinkedmilestone{$r_2$}{7} \\
\ganttlinkedbar{$J_2$}{8}{8} \\
\ganttlinkedbar{$J_3$}{9}{13}
\ganttvrule{}{7}
\ganttvrule{}{5}
\end{ganttchart}
\caption{\label{ganttnonprmp2} Sơ đồ Gantt của bài toán khi đã áp dụng thuật toán không ngắt quãng.}
\end{figure}
\end{vd}

Từ ví dụ minh hoạ ta có thể thấy, công việc thứ $2$ được bắt đầu ở thời điểm $7$, trong khi đó khoảng thời gian từ $5$ đến $7$ trống và cộng dồn khiến $C_{\max}$ từ $11$ tăng lên $13$ và $L_{\max}$ tăng từ $2$ lên $4$. \eqref{ganttnonprmp} \eqref{ganttnonprmp2}

\subsection*{Thuật toán ngắt quãng ($1|prmp|\gamma$)}
\textit{Thuật toán ngắt quãng (preemptive)} là một thuật toán cho phép tạm dừng công việc hiện tại để thực hiện một công việc khác có độ ưu tiên cao hơn. Sau khi công việc ưu tiên cao được hoàn thành, công việc bị tạm dừng sẽ tiếp tục được xử lý từ điểm dừng đã được ghi nhớ trước đó.

Thuật toán này cải thiện điểm hạn chế của thuật toán không ngắt quãng bằng cách cho phép các công việc khác có thể lắp đầy khoảng thời gian rỗi, từ đó giúp tối thiểu hoá tổng thời gian hoàn thành hay độ đáo hạn cực đại và mang lại nhiều ứng dụng trong thực tiễn, nơi công việc có thể được sắp xếp một cách linh hoạt.

Từ ví dụ \eqref{kongatquang}, ta có thể áp dụng thuật toán ngắt quãng để cải thiện giải pháp như sau
\begin{itemize}
\item $t=0:$ Công việc thứ 1 sẵn sàng, bắt đầu xử lý tại $t=0$ và hoàn thành công việc tại thời điểm $t=3$.
\item $t=3:$ Công việc thứ 3 và 4 sẵn sàng, vì 4 có thứ tự ưu tiên cao hơn nên công việc thứ 4 bắt đầu xử lý tại $t=3$ và hoàn thành công việc tại $t=5$.
\item $t=5:$ Lúc này đến công việc thứ 2 nhưng vì thời điểm sẵn sàng $r_2=7$ vì thế ta bỏ qua và tiếp tục công việc có mức độ ưu tiên tiếp theo. Công việc thứ 1 và thứ 4 đã hoàn thành, công việc ưu tiên tiếp theo là công việc thứ 3. Công việc thứ 3 bắt đầu xử lý tại $t=5$ và tạm dừng tại $t=7$ nhường chỗ cho công việc có mức độ ưu tiên cao hơn là công việc thứ 2.
\item $t=7:$ Công việc thứ 2 sẵn sàng, bắt đầu xử lý tại $t=7$ và hoàn thành tại $t=8$.
\item $t=8:$ công việc thứ 2 đã hoàn thành, ta tiếp tục xử lý công việc thứ 3, vì công việc thứ 3 đã bắt đầu tại $t=5$ và tạm dừng tại $t=7$, vậy còn lại 3 đơn vị thời gian cần xử lý còn lại. Ta bắt đầu công việc thứ 3 tại $t=8$ và hoàn thành công việc thứ 3 tại $t=11$.
\item $t=11:$ Tất cả công việc đã hoàn thành và thuật toán dừng.
\end{itemize}

Lúc này giải pháp tối ưu của bài toán là $C_{\max}=11$ và $L_{\max}=2$, mang lại kết quả tối ưu hơn thuật toán không ngắt quãng với $C_{\max}=13$ và $L_{\max}=4$. \eqref{ganttprmp}
\begin{figure}[h!]
\centering
\begin{ganttchart}[
    hgrid,
    vgrid,
    y unit title=.5cm,
    title/.style={draw=none, fill=none},
    include title in canvas=false
]{0}{11}
\gantttitlelist{0,...,11}{1} \\
\ganttmilestone{$r_1$}{0} \\
\ganttlinkedbar{$J_1$}{1}{3} \\
\ganttlinkedmilestone{$r_3,\:r_4$}{3} \\
\ganttlinkedbar{$J_4$}{4}{5} \\
\ganttlinkedbar{$J_3$}{6}{7} \\
\ganttlinkedmilestone{$r_2$}{7} \\
\ganttlinkedbar{$J_2$}{8}{8} \\
\ganttlinkedbar{$J_3$}{9}{11}
\ganttvrule{}{7}
\ganttvrule{}{5}
\end{ganttchart}
\caption{\label{ganttprmp}Sơ đồ Gantt của bài toán khi đã áp dụng thuật toán không ngắt quãng.}
\end{figure}

\subsection*{Thuật toán nhánh cận}
\textit{Thuật toán nhánh cận (branch and bound)} là một khung thuật toán sử dụng cấu trúc cây để xử lý bài toán bằng cách phân nhánh thành các bài toán con và duyệt qua từng bài toán. Về mặt ý tưởng, xuất phát từ giải pháp ban đầu, thuật toán sẽ mở rộng các nhánh thành tập con các bài toán, từ đó liệt kê các phương án khả thi và loại bỏ các phương án không khả thi để thu được phương án tối ưu cuối cùng.

Cụ thể trong lĩnh vực lập lịch, thuật toán nhánh cận được áp dụng để xử lý lớp bài toán có ràng buộc $r_j$ không đồng nhất. Trong những bài toán này, việc sắp xếp các công việc sao cho tối ưu một hàm cụ thể (chẳng hạn như độ đáo hạn cực đại hoặc thời gian hoàn thành cực đại) đòi hỏi phải xem xét nhiều khả năng mà công việc có thể được sắp xếp. Tuy nhiên, do số lượng công việc có thể rất lớn, cụ thể, số cách sắp xếp tăng theo giai thừa của $n$ công việc $(n!)$. Ví dụ, với $10$ công việc, sẽ có đến $10! = 3,628,800$ phương án sắp xếp khác nhau.

Có thể thấy, với số lượng công việc lớn, số lượng phương án khả thi trở nên khổng lồ và rất khó kiểm soát nếu không có một thuật toán loại trừ hiệu quả. Do đó, thuật toán nhánh cận giúp phân tích và loại bỏ các phương án không khả thi bằng điều kiện đã được chứng minh trước đó kết hợp với \textit{cận dưới (lower bound)}. Trong đó, cận dưới là một mục tiêu tối ưu của bài toán được xác định, giúp so sánh sự ưu tiên giữa các nhánh và cũng là một nhân tố quan trọng giúp cải thiện độ phức tạp tính toán một cách hiệu quả. Từ đó giúp thu hẹp không gian nghiệm và tối ưu hóa hiệu quả tính toán.

% Giả sử ta có công việc 1, 2 và 3 cần được sắp xếp, bên dưới là hình minh hoạ cách mà thuật toán nhánh cận hoạt động.

Giả sử ta có ba công việc 1, 2 và 3 cần được sắp xếp. Thuật toán nhánh cận sẽ duyệt qua các tổ hợp phương án khác nhau bằng cách phân nhánh và loại trừ những phương án không khả thi. Dưới đây là hình minh họa về cách thuật toán hoạt động \eqref{bab1}.

\begin{figure}[h!]
	\centering
	\begin{forest} for tree={
		edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}
	}
	[{$***$ ($L_b^{(0)}$).}
		[{$1***$ ($L_{b_0}^{(1)}=7$).}
			[{$123$ ($L_{b_0}^{(2)} =7$).}]
			[{\textbf{132 ($L_{b_1}^{(2)} =5$).}}]
		]
		[{$2***$ ($L_{b_1}^{(1)} =$ 10).}]
		[$3***$]
	]
	\end{forest}
\caption{\label{bab1}Minh hoạ thuật toán nhánh cận.}
\end{figure}


\subsection{Bài toán tối thiểu độ đáo hạn cực đại $L_{\max}$}

Bài toán $1|r_j|L_{\max}$ về cơ bản là phiên bản mở rộng của bài toán $1||L_{\max}$ mà ta đã xử lý trước đó, với sự khác biệt là có thêm ràng buộc về thời điểm sẵn sàng không đồng nhất $r_j$ tại thời điểm $t=0$. Đây là một bài toán quan trọng, đóng vai trò nền tảng cho các bài toán đa máy (multi-machine) mà ta sẽ tìm hiểu sau này. Cùng với đó, bài toán $1|r_j|L_{\max}$ cũng là một trong những bài toán mà thuật toán nhánh cận được áp dụng một cách hiệu quả.

Như đã thảo luận trước đó, cốt lõi của thuật toán nhánh cận nằm ở việc phân chia bài toán thành các bài toán con nhỏ hơn, từ đó duyệt qua các phương án khả thi, đồng thời loại bỏ những phương án không khả thi. Do đó, để giải quyết bài toán $1|r_j|L_{\max}$ một cách hiệu quả, ta cần một kỹ thuật duyệt các bài toán con sao cho tối ưu hóa quá trình tìm kiếm phương án tối ưu. Sau đây, ta sẽ đi sâu vào phương pháp duyệt và phân tích cách thức áp dụng phương pháp duyệt để thu được phương án tối ưu cho bài toán $1|r_j|L_{\max}$.

\subsubsection*{Phương pháp duyệt}

Ứng với $n$ công việc ta có $n! = n \times (n-1) \times (n-2) \times (n-3) \ldots 3 \times 2 \times 1$ phương án sắp xếp. Do đó, xuất phát từ đỉnh cây, ta gọi cấp 0, chứa 0 nút; cấp 1 chứa $n$ nút; cấp 2 chứa $n \times (n-1)$ nút; cấp $k$ chứa $n \times (n-1) \times (n-2) \times (n-3) \ldots (n-k+1)$ nút và cấp $n$ chứa $n \times (n-1) \times (n-2) \times (n-3) \ldots 3 \times 2 \times 1$ nút.

\begin{cy}
Ta ký hiệu $J_i^{(r)}$ là bài toán (hay phương án) nằm ở nút thứ $i$ của cấp thứ $r$, trong đó, nút thứ $i$ được tính bắt đầu từ trái sang phải trên cấu trúc cây, với $i, n \in \mathbb{N}$.
\end{cy}

Vậy đồng nghĩa ở cấp $k$, ta có $k$ công việc đã được sắp xếp

\begin{equation*}
j_1,\ldots ,j_k.
\end{equation*}
Do đó, ta cần xác định công việc $j_{k+1}$ sao cho tối thiểu quá trình phân nhánh. Gọi $J^{'}$ là danh sách công việc chưa được sắp xếp ngoại trừ công việc $j_{k+1}$,

\begin{equation*}
J^{'} = \{j_{k+2},\ldots , j_{n}\}
\end{equation*}
và $l \in J^{'}$. Từ đây ta thu được định lý sau

\begin{dl}[Điều kiện nghiệm]
	Với $l \in J^{'}$, phương án $J_i^{(r)}$ là phương án chấp nhận được khi và chỉ khi $r_{j_{k+1}}$ thoả điều kiện sau,
	\begin{equation} \label{dllmax1}
		r_{j_{k+1}} < \underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l)
	\end{equation}
\end{dl}

\begin{proof}

\phantom{}

Để danh sách công việc được tối ưu, tức không có bất kỳ công việc nào trễ hạn, độ đáo hạn phải luôn nhỏ hơn hoặc bằng 0. Do đó,

\begin{equation*}
	L_l \leq 0,
\end{equation*}
mà ta có $L_l = C_l - d_l$, nên
\begin{equation*}
	C_l - d_l \leq 0,
\end{equation*}
hay
\begin{equation} \label{lmax1}
	C_l \leq d_l.
\end{equation}

Do thuật toán EDD sắp xếp công việc có thời điểm đáo hạn từ nhỏ đến lớn, vậy công việc tiếp theo cần thực hiện phải là 
\begin{equation} \label{lmax2}
\underset{l \in J^{'}}{\min} (d_l).
\end{equation}

Từ \eqref{lmax1} và \eqref{lmax2}, ta được

\begin{equation}
	\underset{l \in J^{'}}{\min} (C_l) \leq \underset{l \in J^{'}}{\min} (d_l).
\end{equation}

Hiển nhiên, thời điểm hoàn thành của công việc tiếp theo, $\underset{l \in J^{'}}{\min}(C_l)$, luôn phải lớn hơn thời điểm xuất phát của công việc trước đó là $r_{j_{k+1}}$, hay
\begin{equation} \label{lmax3}
	\underset{l \in J^{'}}{\min} (C_l) > r_{j_{k+1}}.
\end{equation}

Mặt khác, ta có thể viết $C_l$ dưới dạng sau
\begin{equation} \label{lmax4}
	C_l = \underset{l \in J^{'}}{\max} (t, r_l) + p_l.
\end{equation}

Từ \eqref{lmax3} và \eqref{lmax4}, ta được

\begin{equation} \label{lmax5}
	r_{j_{k+1}} < \underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l)
\end{equation}

Vậy để phương án $J_i^{(r)}$ là phương án chấp nhận được, $r_{j_{k+1}}$ phải thoả điều kiện \eqref{lmax5}. (đpcm)
\end{proof}

\begin{dn}[Cận dưới]
	Với mỗi bài toán $J_i^{(r)}$ nếu thoả điều kiện nghiệm thì luôn tồn tại một phương án chấp nhận được có giá trị tối ưu được gọi là cận dưới của bài toán $J_i^{(r)}$, ký hiệu $L_{b_i}^{(r)}$.
\end{dn}




















% \subsubsection*{Sơ đồ thuật toán}
% Ta gọi nút ban đầu (nút gốc) tại cấp 0 là $J^{(0)}$, tương ứng với mỗi phương án tối ưu $J_i^{(r)}$ ứng với mỗi nút

% Ta gọi phương án $J_i^{(r)}$ có nút ban đầu là $N_0$, tương ứng mỗi bài toán tối ưu tuyến tính thông thường $(P_i)$ ứng với mỗi nút $N_i$ trên sơ đồ nhánh và $\mathcal{L}$ là danh sách chứa các nút được lập thông qua lý thuyết xác định cận và lý thuyết nghiệm.

% Ta đánh dấu giá trị tối ưu tốt nhất và nghiệm tối ưu tốt nhất của bài toán lần lượt là $z^*$ và $(x^*,y^*)$.

% \begin{ttoan}[Nhánh cận]
% \setlength{\parindent}{4em}
% \noindent \\
% \noindent \textbf{Bước 1. Thiết lập}
% Đặt $\mathcal{L}:=\{ N_0^{(1)} \}$, $J^*=J_0^{(1)}$.

% % $z^*=z_p$ và $(x^*,y^*)=(x,y)$. 

% \noindent \textbf{Bước 2. Kiểm tra} 
% Nếu $\mathcal{L} = \emptyset$ thì phương án tối ưu của bài toán là $(x^*,y^*)$, giá trị  tối ưu là $z^*$ và thoả điểu kiện nghiệm thì bài toán được giải, nếu không thoả điều kiện nghiệm ta gọi bài toán không giải được. 
% Trường hợp $\mathcal{L} \neq \emptyset$, chuyển sang bước 3.

% \noindent \textbf{Bước 3. Chọn nút} 
% Chọn nút $N_i$ từ danh sách $\mathcal{L}$ và xoá khỏi $\mathcal{L}$ sau đó chuyển sang  bước 4. 

% \noindent \textbf{Bước 4. Xác định cận}  
% Giải bài toán $(P_i)$, nếu bài toán vô nghiệm hoặc $z_i \leq z^*$, quay  lại bước 2, nếu không, chuyển sang bước 5.

% \noindent \textbf{Bước 5. Gọt nghiệm} 
% Nếu tồn tại $x^{(i)} \notin Z^n_+$, ta thêm nút $N_{i+1}, \ldots , N_{k}$ vào $\mathcal{L}$ và quay  về bước 2. 
% Nếu không tồn tại $x^{(i)} \notin Z^n_+$, tức $\forall x^{(i)} \in Z^n_+$, ta đặt $z_i = z^*$,  $(x^{(i)},y^{(i)}) = (x^*,y^*)$ và quay lại bước 2.
% \end{ttoan}

% \begin{figure}
% \center
% \begin{tikzpicture}[scale=0.33, every node/.style={scale=0.8}, node distance=3cm]
% % Define styles
% \tikzstyle{startstop} = [rectangle, rounded corners, minimum width=1cm, minimum height=1cm, align=center, draw=black, fill=red!30]
% \tikzstyle{process} = [rectangle, minimum width=1cm, minimum height=1cm, align=center, draw=black, fill=orange!30]
% \tikzstyle{decision} = [diamond, aspect=2, minimum width=1cm, minimum height=1cm, align=center, draw=black, fill=green!30]
% \tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=1cm, minimum height=1cm, align=center, draw=black, fill=blue!30]
% \tikzstyle{arrow} = [thick,->,>=stealth,line width=0.2pt]
% % Place nodes
% \node (start) [startstop, xshift=13cm] {Bắt đầu};
% \node (b0) [io, below of=start] {$\mathcal{L}:=\{N_0 \}$ \\ $z^*=z_p$ \\ $(x^*,y^*)=(x,y)$};
% \node (b1) [decision, below of=b0] {$\mathcal{L} = \emptyset$?};
% \node (b2) [process, below of=b1] {Chọn $N_i$ từ $\mathcal{L}$ \\ và xoá khỏi $\mathcal{L}$};
% \node (b3) [process, below of=b2] {Giải $(P_i)$};
% \node (b4) [decision, below of=b3] {Vô nghiệm?};
% \node (b5) [decision, below of=b4] {$\exists x^{(i)} \notin Z^n_+$?};
% \node (b6) [io, right of=b5, node distance = 5cm] {$z_i = z^*$, \\ $(x^{(i)},y^i) = (x,y)$};
% \node (b7) [io, below of=b5] {Thêm \\ $N_{i1}, \ldots , N_{ik}$ \\ vào $\mathcal{L}$};
% \node (stop) [startstop, below of=b7] {Kết thúc};
% % Draw arrows
% \draw [arrow] (start) -- (b0);
% \draw [arrow] (b0) -- (b1);
% \draw [arrow] (b1) -- node[anchor=west] {no} (b2);
% \draw [arrow] (b2) -- (b3);
% \draw [arrow] (b3) -- (b4);
% \draw [arrow] (b4) -- node[anchor=west] {no} (b5);
% \draw [arrow] (b5) -- node[anchor=south] {no} (b6);
% \draw [arrow] (b5) -- node[anchor=west] {yes} (b7);
% \draw [arrow] (b4) --node[anchor=south] {yes} (40,-36.32) |- (b1);
% \draw [arrow] (b6) |- (b1);
% \draw [arrow] (b7) -- (50,-51) |- (b1);
% \draw [arrow] (b7) -- (stop);
% \draw [arrow] (b1) -- node[anchor=south] {yes} (20,-14.51) |- (stop);
% \end{tikzpicture}
% \caption{Minh hoạ lưu đồ giải thuật của thuật toán nhánh cận.}
% \end{figure}
























\begin{vd}
Ta có bảng công việc sau \eqref{vdlmax1}

\begin{figure}[h!]
	\centering
	\begin{tabular}{|c | c c c c |} 
	\hline
	Công việc ($j$) & 1 & 2 & 3 & 4 \\
	\hline\hline
	$p_j$ & 4 & 2 & 6 & 5 \\
	$r_j$ & 0 & 1 & 3 & 5 \\
	$d_j$ & 8 & 12 & 11 & 10 \\
	\hline
	\end{tabular}
\caption{\label{vdlmax1} Dữ liệu minh hoạ bài toán $1 | r_j | L_{\max}$.}
\end{figure}

Bằng cách áp dụng thuật toán nhánh cận, ta thu được sơ đồ cây cấp 1 như sau \eqref{vdlmax2}


\begin{figure}[h!]
	\centering
	\begin{forest} for tree={
		edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}
	}
	[{$****$}
		[$1***$
		]
		[$2***$]
		[$3***$]
		[$4***$]
	]
	\end{forest}
\caption{\label{vdlmax2} Sơ đồ cây cấp 1.}
\end{figure}

Ở phương án $J_0^{(1)}$ $(1***)$ có $r_{j_{k+1}} = r_1 = 0$, áp dụng phương pháp duyệt, ta xét điều kiện nghiệm

\begin{figure}[h!]
	\centering
	\begin{tabular}{|c | c c c c |} 
	\hline
	Công việc ($j$) & 1 & 2 & 3 & 4 \\
	\hline\hline
	$p_j$ & 4 & 2 & 6 & 5 \\
	$r_j$ & 0 & 1 & 3 & 5 \\
	$d_j$ & 8 & 12 & 11 & 10 \\
	$\underset{l \in J^{'}}{\max} (t, r_l) + p_l$ & & 3 & 9 & 10 \\ 
	\hline
	\end{tabular}
\caption{\label{vdlmax00} Bảng dữ liệu $\underset{l \in J^{'}}{\max} (t, r_l) + p_l$ cho phương án $J_0^{(1)}$.}
\end{figure}

Từ bảng \eqref{vdlmax00}, ta được
\begin{equation*}
\underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l) = 3 > r_{j_{k+1}},
\end{equation*}
vậy phương án $J_0^{(1)}$ thoả điều kiện nghiệm.

Tương tự, ở phương án $J_1^{(1)}$ $(2***)$ có $r_{j_{k+1}} = r_2 = 1$, xét điều kiện nghiệm ta được

\begin{equation*}
\underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l) = 4 > r_{j_{k+1}},
\end{equation*}
vậy phương án $J_1^{(1)}$ thoả điều kiện.


Ở phương án $J_2^{(1)}$ $(3***)$ có $r_{j_{k+1}} = r_3 = 3$, xét điều kiện nghiệm ta được

\begin{equation*}
\underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l) = 3 = r_{j_{k+1}},
\end{equation*}
vậy phương án $J_2^{(1)}$ không thoả điều kiện.

Tương tự, ở phương án $J_3^{(1)}$ $(4***)$ có $r_{j_{k+1}} = r_4 = 5$, xét điều kiện nghiệm ta được

\begin{equation*}
\underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l) = 3 < r_{j_{k+1}},
\end{equation*}
vậy phương án $J_3^{(1)}$ không thoả điều kiện.

Ta giữ lại các phương án thoả điều kiện nghiệm, gồm phương án $J_0^{(1)}$, $J_1^{(1)}$. Từ đây, ta tiếp tục xét cận dưới của các phương án.

Ở phương án $J_0^{(1)}$, áp dụng thuật toán EDD, ta thu được

\begin{figure}[h!]
	\centering
	\begin{tabular}{|c | c c c c |} 
	\hline
	Công việc ($j$) & 1 & 4 & 3 & 2 \\
	\hline\hline
	$p_j$ & 4 & 5 & 6 & 2 \\
	$r_j$ & 0 & 5 & 3 & 1 \\
	$d_j$ & 8 & 10 & 11 & 12 \\
	$L_{\max}$ & -4 & -1 & 4 & 5 \\ 
	\hline
	\end{tabular}
\caption{\label{eddj01} Bảng dữ liệu thuật toán EDD cho phương án $J_0^{(1)}$.}
\end{figure}

Từ bảng \eqref{eddj01}, cận dưới của phương án $J_0^{(1)}$ là $L_{b_0}^{(1)} = 5$.

Tương tự, ở phương án $J_1^{(1)}$

\begin{figure}[h!]
	\centering
	\begin{tabular}{|c | c c c c |} 
	\hline
	Công việc ($j$) & 2 & 1 & 4 & 3 \\
	\hline\hline
	$p_j$ & 2 & 4 & 5 & 6 \\
	$r_j$ & 1 & 0 & 5 & 3 \\
	$d_j$ & 12 & 8 & 10 & 11 \\
	$L_{\max}$ & -10 & -2 & 1 & 6 \\ 
	\hline
	\end{tabular}
\caption{\label{eddj11} Bảng dữ liệu thuật toán EDD cho phương án $J_1^{(1)}$.}
\end{figure}

Từ \eqref{eddj11}, cận dưới của phương án $J_1^{(1)}$ là $L_{b_1}^{(1)} = 6$.

Từ đây, ta dễ dàng loại trừ phương án $J_1^{(1)}$ do $L_{b_0}^{(1)} < L_{b_1}^{(1)}$ \eqref{treelmax1} và tiếp tục phân nhánh với gốc nằm ở phương án $J_0^{(1)}$.

\begin{figure}[h!]
	\centering
	\begin{forest} for tree={
		edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}
	}
	[{$****$ ($L_b^{(0)}$).}
		[{$1***$ ($L_{b_0}^{(1)} =$ 5).}
		]
		[{$2***$ ($L_{b_1}^{(1)} =$ 6).}]
		[$3***$]
		[$4***$]
	]
	\end{forest}
\caption{\label{treelmax1} Sơ đồ cây cấp 1 với cận dưới.}
\end{figure}


Vì công việc 1 đã được sắp, do đó $t=4$.

Phương án $J_0^{(2)}$ $(12**)$ có $r_{j_{k+1}} = r_2 = 1$, xét điều kiện nghiệm ta được

\begin{equation*}
\underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l) = 10 > r_{j_{k+1}},
\end{equation*}
vậy phương án $J_0^{(2)}$ thoả điều kiện, tương tự, ta thu được $L_{b_0}^{(2)} = 6$.

Phương án $J_1^{(2)}$ $(13**)$ có $r_{j_{k+1}} = r_3 = 3$, xét điều kiện nghiệm ta được

\begin{equation*}
\underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l) = 6 > r_{j_{k+1}},
\end{equation*}
vậy phương án $J_1^{(2)}$ thoả điều kiện, tương tự, ta thu được $L_{b_1}^{(2)} = 5$.

Phương án $J_2^{(2)}$ $(14**)$ có $r_{j_{k+1}} = r_4 = 5$, xét điều kiện nghiệm ta được

\begin{equation*}
\underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l) = 6 > r_{j_{k+1}},
\end{equation*}
vậy phương án $J_2^{(2)}$ thoả điều kiện, tương tự, ta thu được $L_{b_2}^{(2)} = 5$.

Từ đây, ta dễ dàng loại trừ phương án $J_0^{(2)}$ \eqref{treelmax2} và tiếp tục phân nhánh với gốc nằm ở phương án $J_1^{(2)}$ và $J_2^{(2)}$.


\begin{figure}[h!]
	\centering
	\begin{forest} for tree={
		edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}
	}
	[{$****$ ($L_b^{(0)}$).}
		[{$1***$ ($L_{b_0}^{(1)} =$ 5).}
			[{$12**$ ($L_{b_0}^{(2)} =$ 6).}]
			[{$13**$ ($L_{b_1}^{(2)} =$ 5).}
			]
			[{$14**$ ($L_{b_2}^{(2)} =$ 5).}
			]
		]
		[{$2***$ ($L_{b_1}^{(1)} =$ 6).}]
		[$3***$]
		[$4***$]
	]
	\end{forest}
\caption{\label{treelmax2} Sơ đồ cây cấp 2 với cận dưới.}
\end{figure}

Thực hiện thuật toán tương tự, ta được $J_0^{(3)}$, $J_1^{(3)}$, $J_2^{(3)}$ và $J_3^{(3)}$ đều thoả điều kiện nghiệm với cận dưới lần lượt là $7,5,5,6$. \eqref{treelmax3}

\begin{figure}[h!]
	\centering
	\begin{forest} for tree={
		edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}
	}
	[{$****$ ($L_b^{(0)}$).}
		[{$1***$ ($L_{b_0}^{(1)} =$ 5).}
			[{$12**$ ($L_{b_0}^{(2)} =$ 6).}]
			[{$13**$ ($L_{b_1}^{(2)} =$ 5).}
				[{$1324$ ($L_{b_0}^{(3)} =$ 7).}]
				[{\textbf{1342 ($L_{b_1}^{(3)} =$ 5).}}]
			]
			[{$14**$ ($L_{b_2}^{(2)} =$ 5).}
				[{$1432$ ($L_{b_2}^{(3)} =$ 5).}]
				[{$1423$ ($L_{b_3}^{(3)} =$ 6).}]
			]
		]
		[{$2***$ ($L_{b_1}^{(1)} =$ 6).}]
		[$3***$]
		[$4***$]
	]
	\end{forest}
\caption{\label{treelmax3} Sơ đồ cây cấp 3 với cận dưới.}
\end{figure}


Loại trừ phương án $J_0^{(3)}$ và phương án $J_3^{(3)}$. Ta áp dụng thuật toán không ngắt quãng, ở phương án $J_1^{(3)}$ ta có $C_{\max _1}^{(3)} = 17$ \eqref{gantcmax13}, phương án $J_2^{(3)}$ có $C_{\max _2}^{(3)} = 18$ \eqref{gantcmax23}. Từ đây ta thu được phương án tối ưu là phương án $J_1^{(3)}$ do $C_{\max _1}^{(3)} < C_{\max _2}^{(3)}$.

Vậy phương án tối ưu của bài toán là $1-3-4-2$.

Áp dụng thuật toán ngắt quãng cho phương án $J_3^{(3)}$, ta được sơ đồ \eqref{gantcmax23prmp}. Từ đây, nếu áp dụng thuật toán ngắt quãng, ta có thể thu một trong hai phương án $J_0^{(3)}$ hay $J_3^{(3)}$ đều tối ưu.

\end{vd}

Ta gọi bài toán có áp dụng thuật toán ngắt quãng là bài toán $1|prmp|L_{\max}$. Bài toán $1|prmp|L_{\max}$ đơn giản là bài toán $1|r_j|L_{\max}$, trong đó, ta mở rộng việc áp dụng thuật toán ngắt quãng để thu được phương án tối ưu.

% \Tree [.CP [[.{***} {which car} ] {\ldots}] .a ]

\subsection{Bài toán tối thiểu thời gian hoàn thành cực đại $C_{\max}$}

% Một bài toán tương tự cũng sử dụng thuật toán nhánh cận để xử lý mà ta không thể bỏ qua là bài toán tối thiểu thời gian hoàn thành cực đại, ký hiệu $1|r_j|C_{\max}$.

% Tương tự với bài toán tối thiểu độ đáo hạn cực đại $1|r_j|L_{\max}$, bài toán $1|r_j|C_{\max}$ cũng áp dụng điều kiện nghiệm tương tự nhưng cận dưới giờ đây được thay bằng giá trị $C_{\max}$ cho mỗi phương án chấp nhận được đã thu được.

% Do đó, quy trình thuật toán hoàn toàn tương tự, chỉ khác nhau ở cách xét cận dưới cho mỗi phương án chấp nhận được.

Một bài toán tương tự sử dụng thuật toán nhánh cận để giải quyết là bài toán tối thiểu thời gian hoàn thành cực đại, ký hiệu $1|r_j|C_{\max}$. Giống như bài toán tối thiểu độ dao hạn cực đại $1|r_j|L_{\max}$, bài toán $1|r_j|C_{\max}$ cũng áp dụng cùng một điều kiện nghiệm, nhưng cận dưới ở đây là giá trị $C_{\max}$ đối với mỗi phương án chấp nhận được. Do đó, quy trình thuật toán được thực hiện tương tự, với điểm khác biệt duy nhất là cách tính cận dưới cho mỗi phương án.

\begin{vd} \label{vdrjcmax1}
Ta có bảng công việc sau \eqref{vdcmax1}

\begin{figure}[h!]
	\centering
	\begin{tabular}{|c | c c c |} 
	\hline
	Công việc ($j$) & 1 & 2 & 3 \\
	\hline\hline
	$p_j$ & 3 & 2 & 4 \\
	$r_j$ & 3 & 7 & 5 \\
	$d_j$ & 8 & 12 & 11 \\
	\hline
	\end{tabular}
\caption{\label{vdcmax1} Dữ liệu minh hoạ bài toán $1 | r_j | C_{\max}$.}
\end{figure}



Bằng cách áp dụng thuật toán nhánh cận, ta thu được sơ đồ cây cấp 1 như sau \eqref{vdlmax2}


\begin{figure}[h!]
	\centering
	\begin{forest} for tree={
		edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}
	}
	[{$***$}
		[$1**$
		]
		[$2**$]
		[$3**$]
	]
	\end{forest}
\caption{\label{vdlmax2} Sơ đồ cây cấp 1.}
\end{figure}

Ở phương án $J_0^{(1)}$ $(1**)$ có $r_{j_{k+1}} = r_1 = 3$, áp dụng phương pháp duyệt, ta xét điều kiện nghiệm

\begin{figure}[h!]
	\centering
	\begin{tabular}{|c | c c c |} 
	\hline
	Công việc ($j$) & 1 & 3 & 2 \\
	\hline\hline
	$p_j$ & 3 & 4 & 2 \\
	$r_j$ & 3 & 5 & 7 \\
	$d_j$ & 8 & 11 & 12 \\
	$\underset{l \in J^{'}}{\max} (t, r_l) + p_l$ & & 9 & 9 \\ 
	\hline
	\end{tabular}
\caption{\label{vdcmax00} Bảng dữ liệu $\underset{l \in J^{'}}{\max} (t, r_l) + p_l$ cho phương án $J_0^{(1)}$.}
\end{figure}

Từ bảng \eqref{vdcmax00}, ta được
\begin{equation*}
\underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l) = 9 > r_{j_{k+1}},
\end{equation*}
vậy phương án $J_0^{(1)}$ thoả điều kiện nghiệm.

Tương tự, ở phương án $J_1^{(1)}$ $(2**)$ có $r_{j_{k+1}} = r_2 = 7$, xét điều kiện nghiệm ta được

\begin{equation*}
\underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l) = 6 < r_{j_{k+1}},
\end{equation*}
vậy phương án $J_1^{(1)}$ không thoả điều kiện.


Ở phương án $J_2^{(1)}$ $(3**)$ có $r_{j_{k+1}} = r_3 = 5$, xét điều kiện nghiệm ta được

\begin{equation*}
\underset{l \in J^{'}}{\min} (\underset{l \in J^{'}}{\max} (t, r_l) + p_l) = 6 > r_{j_{k+1}},
\end{equation*}
vậy phương án $J_2^{(1)}$ thoả điều kiện.

Ta giữ lại các phương án thoả điều kiện nghiệm, gồm phương án $J_0^{(1)}$, $J_2^{(1)}$. Từ đây, ta tiếp tục xét cận dưới của các phương án.

Ở phương án $J_0^{(1)}$, áp dụng thuật toán EDD, ta thu được danh sách công việc là $1-3-2$. Tiếp tục áp dụng thuật toán không ngắt quãng, ta được $C_{\max} = 12$ (xem sơ đồ \eqref{gantcmax23-cmax}), vậy ta thu được cận dưới $L_{b_0}^{(1)} = 12$. Tương tự với phương án $J_1^{(1)}$, ta thu được cận dưới $L_{b_1}^{(1)} = 14$.

Từ đây, ta dễ dàng loại trừ phương án $J_1^{(1)}$ do $L_{b_0}^{(1)} < L_{b_1}^{(1)}$ và tiếp tục phân nhánh với gốc nằm ở phương án $J_0^{(1)}$. \eqref{vdcmaxcap1canduoi}

Thực hiện thuật toán tương tự, ta được $J_0^{(2)}$ và $J_1^{(2)}$ đều thoả điều kiện nghiệm với cận dưới lần lượt là $13,12$. \eqref{vdcmaxcap2canduoi}

Vậy phương án tối ưu của bài toán là $1-3-2$.



















\begin{figure}[h!]
	\centering
	\begin{forest} for tree={
		edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}
	}
	[{$***$ ($L_b^{(0)}$).}
		[{$1**$ ($L_{b_0}^{(1)} =$ 12).}
		]
		[$2**$]
		[{$3**$ ($L_{b_1}^{(1)} =$ 14).}]
	]
	\end{forest}
\caption{\label{vdcmaxcap1canduoi} Sơ đồ cây cấp 1 với cận dưới.}
\end{figure}

\begin{figure}[h!]
	\centering
	\begin{forest} for tree={
		edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}
	}
	[{$***$ ($L_b^{(0)}$).}
		[{$1**$ ($L_{b_0}^{(1)} =$ 12).}
			[{$123$ ($L_{b_0}^{(2)} =$ 13).}]
			[{\textbf{132 ($L_{b_1}^{(2)} =$ 12).}}]
		]
		[$2**$]
		[{$3**$ ($L_{b_1}^{(1)} =$ 14).}]
	]
	\end{forest}
\caption{\label{vdcmaxcap2canduoi} Sơ đồ cây cấp 2 với cận dưới.}
\end{figure}

\end{vd}

\section*{Trang chỉ mục / Phụ lục}
\addcontentsline{toc}{section}{Phụ lục}

\begin{figure}[h!]
\centering
\begin{ganttchart}[
    hgrid,
    vgrid,
    y unit title=.5cm,
    title/.style={draw=none, fill=none},
    include title in canvas=false
]{1}{17}
\gantttitlelist{0,...,17}{1} \\
\ganttmilestone{$r_1 \quad$}{0} \\
\ganttlinkedbar{Job 1 $\quad$}{1}{1} \\
\ganttlinkedmilestone{$r_2 \quad$}{1} \\
\ganttlinkedbar{Job 1 $\quad$}{2}{3} \\
\ganttlinkedmilestone{$r_3 \quad$}{3} \\
\ganttlinkedbar{Job 1 $\quad$}{4}{4} \\
\ganttlinkedbar{Job 3 $\quad$}{5}{5} \\
\ganttlinkedmilestone{$r_4 \quad$}{5} \\
\ganttlinkedbar{Job 3 $\quad$}{6}{10} \\
\ganttlinkedbar{Job 4 $\quad$}{11}{15} \\
\ganttlinkedbar{Job 2 $\quad$}{16}{17}
\end{ganttchart}
\caption{\label{gantcmax13} Sơ đồ Gantt không ngắt quãng của phương án $J_1^{(3)}$.}
\end{figure}

\begin{figure}[h!]
\centering
\begin{ganttchart}[
    hgrid,
    vgrid,
    y unit title=.5cm,
    title/.style={draw=none, fill=none},
    include title in canvas=false
]{1}{18}
\gantttitlelist{0,...,18}{1} \\
\ganttmilestone{$r_1 \quad$}{0} \\
\ganttlinkedbar{Job 1 $\quad$}{1}{1} \\
\ganttlinkedmilestone{$r_2 \quad$}{1} \\
\ganttlinkedbar{Job 1 $\quad$}{2}{3} \\
\ganttlinkedmilestone{$r_3 \quad$}{3} \\
\ganttlinkedbar{Job 1 $\quad$}{4}{4} \\
\ganttlinkedmilestone{$r_4 \quad$}{5} \\
\ganttlinkedbar{Job 4 $\quad$}{6}{10} \\
\ganttlinkedbar{Job 3 $\quad$}{11}{16} \\
\ganttlinkedbar{Job 2 $\quad$}{17}{18}
\ganttvrule{}{4}
\ganttvrule{}{5}
\end{ganttchart}
\caption{\label{gantcmax23} Sơ đồ Gantt không ngắt quãng của phương án $J_2^{(3)}$.}
\end{figure}

\begin{figure}[h!]
\centering
\begin{ganttchart}[
    hgrid,
    vgrid,
    y unit title=.5cm,
    title/.style={draw=none, fill=none},
    include title in canvas=false
]{1}{17}
\gantttitlelist{0,...,17}{1} \\
\ganttmilestone{$r_1 \quad$}{0} \\
\ganttlinkedbar{Job 1 $\quad$}{1}{1} \\
\ganttlinkedmilestone{$r_2 \quad$}{1} \\
\ganttlinkedbar{Job 1 $\quad$}{2}{3} \\
\ganttlinkedmilestone{$r_3 \quad$}{3} \\
\ganttlinkedbar{Job 1 $\quad$}{4}{4} \\
\ganttlinkedbar{Job 2 $\quad$}{5}{5} \\
\ganttlinkedmilestone{$r_4 \quad$}{5} \\
\ganttlinkedbar{Job 4 $\quad$}{6}{10} \\
\ganttlinkedbar{Job 3 $\quad$}{11}{16} \\
\ganttlinkedbar{Job 2 $\quad$}{17}{17}
\end{ganttchart}
\caption{\label{gantcmax23prmp} Sơ đồ Gantt ngắt quãng của phương án $J_2^{(3)}$.}
\end{figure}

\begin{figure}[h!]
\centering
\begin{ganttchart}[
    hgrid,
    vgrid,
    y unit title=.5cm,
    title/.style={draw=none, fill=none},
    include title in canvas=false
]{1}{12}
\gantttitlelist{0,...,12}{1} \\
\ganttmilestone{$r_1$}{3} \\
\ganttlinkedbar{Job 1}{4}{5} \\
\ganttlinkedmilestone{$r_3$}{5} \\
\ganttlinkedbar{Job 1}{6}{6} \\
\ganttlinkedbar{Job 3}{7}{7} \\
\ganttlinkedmilestone{$r_2$}{7} \\
\ganttlinkedbar{Job 3}{8}{10} \\
\ganttlinkedbar{Job 2}{11}{12}
\ganttvrule{}{0}
\ganttvrule{}{3}
\end{ganttchart}
\caption{\label{gantcmax23-cmax} Sơ đồ Gantt không ngắt quãng của phương án $J_0^{(1)}$.}
\end{figure}














\nocite{*}
\bibliographystyle{plain}
\bibliography{tailieu}
\end{document}